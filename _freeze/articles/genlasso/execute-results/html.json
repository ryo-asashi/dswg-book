{
  "hash": "9d8a997bca70942f6cefec3865fa1502",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"genlasso\"\nauthor: \"データサイエンス関連基礎調査WG\"\ndate: \"2025-08-01\"\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    fig-width: 6\n    fig-height: 5\n    df-print: \"paged\"\n    embed-resources: true\nreferences:\n- id: BIB_GENLASSO_VIGNETTE\n  type: article\n  title: \"Introduction to the genlasso package\"\n  URL: https://ryantibs.r-universe.dev/genlasso/doc/article.pdf\n  author:\n    - Taylor B. Arnold\n    - Ryan Tibshirani\n  issued:\n    - year: 2019\n  accessed:\n    - year: 2025\n      month: 2\n      day: 19\n- id: BIB_TIBSHIRANI_2011\n  type: article\n  title: The Solution Path of the Generalized Lasso\n  URL: https://www.stat.cmu.edu/~ryantibs/papers/genlasso.pdf\n  author:\n    - Ryan J. Tibshirani\n    - Jonathan Taylor\n  issued:\n    - year: 2011\n- id: BIB_ARNOLD_2016\n  type: article\n  title: Efficient Implementations of the Generalized Lasso Dual Path Algorithm\n  URL: https://www.stat.cmu.edu/~ryantibs/papers/fastgl.pdf\n  author:\n    - Taylor B. Arnold\n    - Ryan J. Tibshirani\n  issued:\n    - year: 2016\n- id: BIB_BOOK_IWASAWA\n  type: book\n  publisher: 東京図書\n  title: 入門 Rによる予測モデリング\n  author:\n    - 岩沢 宏和\n    - 平松 雄司\n  issued:\n    date-parts:\n    - - 2019\n      - 11\n      - 25\n- id: BIB_AGLM_2019_JARIP\n  type: article\n  title: アクチュアリー実務のためのデータサイエンスの技術を用いたGLMの拡張\n  URL: https://www.jarip.org/publication/risk_and_insurance/pdf/RI_v15_045.pdf\n  author:\n    - 藤田 卓\n    - 田中 豊人\n    - 岩沢 宏和\n  issued:\n    - year: 2019\n- id: BIB_AGLM_2020\n  type: article\n  title: A Hybrid Modeling Method of GLM and Data Science Techniques\n  URL: https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&fg=1\n  author:\n    - Suguru Fujita\n    - Toyoto Tanaka\n    - Kenji Kondo\n    - Hirokazu Iwasawa\n  issued:\n    - year: 2020\nnocite: |\n  @*\n---\n\n\n\n\n\n::: {.cell}\n<style type=\"text/css\">\n.output-jp > code {\n/*一部日本語出力があるチャンクで日本語と英字の幅が揃わずに表示がずれるため、CSSでフォントを変更することで表示を揃える*/\n  font-family: \"ＭＳ ゴシック\";\n}\n</style>\n:::\n\n\n\n\n## パッケージの概要\n\ngenlassoパッケージはラッソ正則化線形回帰モデルについて、\n通常のものよりも罰則項を一般化したモデルを取り扱うものです。\n加えて、フューズドラッソ（Fused LASSO）等の特別なパターンについてはより効率的なアルゴリズムを用意しています。\nなお、GLM には対応していません。\n\n### 一般化ラッソ回帰問題とは\n\nまず、本パッケージが取り扱う一般化ラッソ回帰問題について簡単に説明します。\n\n実数値の説明変数が $k$ 個・目的変数が1個あり、\nこれらについて $n$ 組の観測がある場合の線形回帰問題を考えます。\n\n通常の線形回帰問題は、説明変数の実測値を表す $n$ 行 $k$ 列実数値行列 $X = (x_{ij})$ と目的変数の実測値を表す $y = (y_i)_{i=1}^n \\in \\mathbb{R} ^ n$ に対して、\n\n$$\n\\sum_{i=1}^{n}\\left(y_i - \\sum_{j=1}^{k} \\left( x_{ij} \\cdot \\beta_j \\right) \\right)^2\n$$\nを最小化するような $\\beta = (\\beta_j)_{j=1}^k \\in \\mathbb{R}^k$ を求める問題（最小二乗法）として定式化されます。\n\nベクトル $v = (v_i)_{i=1}^m \\in \\mathbb{R}^m$ と $1 \\leq p < \\infty$ に対し、\n$p$ - ノルム $\\|v\\|_p := \\left( \\sum_{i=1}^m |v_i|^p \\right)^{1/p}$\nが定義されます。これを用いると、最小化すべき関数は \n\n$$\n\\| y - X\\beta \\|_2^2 \n$$\n\nと簡単に書けます。\n\nこれを少し変更した、 \n\n$$\n\\frac12\\| y - X\\beta \\|_2^2 + \\lambda\\| \\beta \\|_1\n$$\n\nを最小化する問題を**ラッソ回帰問題** [^intercept] といいます。\nここで、$\\lambda \\geq 0$ はモデルのハイパーパラメータです。\n\n[^intercept]: ここでは切片項を省略して表示しています。\n\nこの第2項をラッソ罰則項といい、これにより線形回帰モデルの解が安定しやすくなります。\nこのように、最小化問題にラッソ罰則項を付け加えることを**ラッソ正則化**といい、\n特に予測モデル構築の観点では、予測精度が向上し、かつ**変数選択が自動的に行われる**ことが知られています[@BIB_BOOK_IWASAWA]。\n入力データに比して説明変数が非常に多い場合のような、いわゆるスパースモデリングのための重要手法として深く研究されています。\n\n本パッケージで取り扱う一般化ラッソ回帰問題とは、この罰則項をさらに一般化した\n\n$$\n\\frac12\\| y - X\\beta \\|_2^2 + \\lambda\\| D \\beta \\|_1\n$$\nの最小化問題を取り扱うものです。ただし、$D$ は $l$ 行 $k$ 列実数値行列です。\n\nこの中には、罰則項を $\\lambda \\sum_{i=1}^{k-1} | \\beta_{i+1} - \\beta_{i}  |$ とした、\nいわゆる**フューズドラッソ**回帰問題も含まれます。\n隣接した説明変数同士の係数が同じ値に近づくような作用を与え、ノイズ除去などに用いられます。\n一般化ラッソ回帰問題にて $D$ を次のように設定することでこの問題に帰着します。\n\n$$\nD = \\begin{bmatrix}\n-1 & 1 & 0 & 0 & \\cdots & 0 & 0\\\\\n0 & -1 & 1 & 0 & \\cdots & 0 & 0 \\\\\n &  & \\vdots &  & \\ddots & \\vdots &  \\\\\n0 & 0 & 0 & 0 & \\cdots & -1 & 1 \\\\\n\\end{bmatrix}\n$$\n\n本パッケージが優れているのは、この一般化ラッソ回帰問題について @BIB_ARNOLD_2016 の手法を実装することにより、\n解パス、すなわちすべての $\\lambda$ に対する解を一度に与えることができることです。\nこれにより、$\\lambda$ を変更したときの振る舞いを観察したり、\nハイパーパラメータ $\\lambda$ のチューニングに活用したりすることができます。\n\n## 準備\n\n### パッケージの読み込み\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(genlasso)\nlibrary(ggplot2) #可視化に使用\n```\n:::\n\n\n\n\n### データセットの読み込み\n\nBostonデータセットとはボストンの住宅価格に関するデータで、\n今回は`medv`（住宅価格）を目的変数とし、これを他の説明変数で予測するモデルを構築することとします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n#学習用データと評価用データを分割します。\ndf_all <- MASS::Boston\nsplit_df_all <- rsample::initial_split(df_all)\n\n#学習用データを説明変数と目的変数に分割します。\ndf_train <- rsample::training(split_df_all)\ndf_train_X <- dplyr::select(df_train, -medv)\ndf_train_y <- df_train$medv\n\n#評価用データを説明変数と目的変数に分割します。\ndf_test <- rsample::testing(split_df_all)\ndf_test_X <- dplyr::select(df_test, -medv)\ndf_test_y <- df_test$medv\n```\n:::\n\n\n\n\n## 使用方法\n\n### 通常のラッソ回帰問題 {#sec-genlasso-basic}\n\nBostonデータセットにて、罰則項を $\\lambda \\|\\beta\\|$  とする通常のラッソ回帰モデルを構築することを考えます。\n\n罰則項の存在から、説明変数のスケールの違いにより最小化問題の解が変わるという性質があります。\n\n例えば、ある説明変数だけを全ての観測で一様に10倍すると、\n通常の線形回帰問題では対応する係数を10分の1すればよいだけですが、\nラッソ回帰問題では罰則項における評価が他の説明変数に比べて10分の1になってしまい、\n最小化問題の解が変わってしまいます。\n\nスケールの違いによって解が変わらないようにするため、\n平均がゼロ、分散を1になるように線形変換する標準化（normalize）を最初に行うこととします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#標準化のため、recipesパッケージを使用します。\n#「標準化する」という手順書を作成し、これを変数に格納します。\nrec_nm <- recipes::recipe(df_train, medv ~ .) |> \n  #全ての説明変数を標準化\n  recipes::step_normalize(recipes::all_numeric_predictors())\n\n#学習用データに基づき、標準化に使用する変換方法を具体的に決定します。\n#（これにより、評価用データに対しても学習データと同じルールで変換できます）\nrecp_nm <- rec_nm |> recipes::prep()\n\n#標準化したデータを別の変数に格納します。\ndf_train_nm <- recp_nm |> recipes::bake(new_data = df_train)\ndf_train_X_nm <- dplyr::select(df_train_nm, -medv)\n\ndf_test_nm <- recp_nm |> recipes::bake(new_data = df_test)\ndf_test_X_nm <- dplyr::select(df_test_nm, -medv)\n```\n:::\n\n\n\n\nまた、genlassoパッケージには切片項を明示的に追加する機能がないため、\n学習用データに全件1を入力した列を追加することで対応します。\n\n`model.matrix`関数は計画行列を作成するための汎用的な関数ですが、\n今回の場合は以下のようにすることで、切片項の列を追加するのに使用できます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_train_1X_nm <- model.matrix(~ ., df_train_X_nm)\n```\n:::\n\n\n\n\n\n\n次に、罰則項の係数行列 $D$ の設定をします。\n通常のラッソ回帰の場合は単位行列 $I$ を指定した場合に対応しますが、\n切片項の分だけ $D$ の列数も1列増やしておく必要があります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- diag(1, ncol(df_train_X)+1)\n```\n:::\n\n\n\n\nさらに、切片項に対しては罰則項の対象外とするため、1行目は取り除きます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- D[-1,]\n```\n:::\n\n\n\n\nこれで、回帰問題の設定に用いる変数は全て用意できました。\n\n後は、`genlasso`関数に目的変数の実測値`y`、説明変数の実測値（計画行列）`X`、\n罰則項の係数行列`D`を入力することで回帰モデルが構築できます。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_genlasso <- genlasso(y = df_train_y,\n                           X = df_train_1X_nm, \n                           D = D)\n```\n:::\n\n\n\n\n構築したモデルに対して`plot`関数を適用すると、\nλによってどのように係数が変化するか（解パス）をプロットすることができます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(model_genlasso)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/basic_plotpath-1.png){width=576}\n:::\n:::\n\n\n\n\nこのプロットにより、正則化によってどのように変数選択されていくかを可視化することができます。\n\n今回のようにモデリングで使用する部分がグラフの左の方に固まってしまうケースでは\nその部分を拡大して観察したほうが良いように思われますが、\n標準ではこのグラフを拡大する方法は用意されていません。\n\nグラフの範囲は `$lambda[1]` によって決定されているので、\nこれを上書きすることで強引に拡大することは可能です。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_genlasso_tmp <- model_genlasso\nmodel_genlasso_tmp$lambda[1] <- 1*nrow(df_train_X)\nplot(model_genlasso_tmp)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/basic_plotpath_zoom-1.png){width=576}\n:::\n\n```{.r .cell-code}\nmodel_genlasso_tmp$lambda[1] <- 0.1*nrow(df_train_X)\nplot(model_genlasso_tmp)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/basic_plotpath_zoom-2.png){width=576}\n:::\n:::\n\n\n\n\nまた、λと説明変数の個数の関係は`summary`関数でも確認できます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model_genlasso)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   df    lambda     rss\n    1   2511.89   30958\n    2   2082.40   25737\n    3   1072.16   15226\n    4    404.69   10990\n    5    294.27   10549\n    6    291.33   10538\n    7    248.56   10355\n    8    173.02    9839\n    9     94.48    9210\n   10     94.16    9208\n   11     87.99    9131\n   12     54.55    8764\n   13     30.97    8507\n```\n\n\n:::\n:::\n\n\n\n\n特定のλでの係数を確認するには、`coef`関数を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(model_genlasso, lambda = c(0.01, 0.1, 1, 10)*nrow(df_train_X))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$beta\n             3.79          37.9           379          3790\n [1,] 22.44828496  2.244828e+01  2.244828e+01  2.244828e+01\n [2,] -1.07583207 -7.910061e-01  9.508378e-16  4.149459e-15\n [3,]  0.82295065  4.282012e-01  3.012037e-16 -6.106227e-15\n [4,] -0.03736614 -1.739666e-01  3.363591e-16  3.171075e-15\n [5,]  0.47094307  4.555891e-01 -7.536400e-16  2.844947e-16\n [6,] -2.10978311 -1.679800e+00 -1.552797e-15  4.274359e-15\n [7,]  2.49902980  2.618992e+00  2.546729e+00 -1.122713e-14\n [8,] -0.16356541 -5.582320e-16  2.360366e-15  5.152129e-15\n [9,] -3.24170209 -2.466214e+00  2.635306e-16  4.676814e-15\n[10,]  2.63338674  1.281014e+00 -3.570671e-15  1.942890e-15\n[11,] -1.74110608 -5.748326e-01  3.045836e-15 -7.410739e-15\n[12,] -2.15187674 -2.025676e+00 -1.220700e+00 -5.925815e-15\n[13,]  0.68719108  6.315578e-01  5.366666e-02 -2.997602e-15\n[14,] -3.84759123 -3.899315e+00 -3.662125e+00 -2.975051e-15\n\n$lambda\n[1]    3.79   37.90  379.00 3790.00\n\n$df\n[1] 14 13  5  1\n```\n\n\n:::\n:::\n\n\n\n\nこの回帰モデルで予測を行うには、`predict`関数を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#λの値はそれなりの精度になるものを手で検証して設定しました。\nlambda_gen <- 0.027 * nrow(df_train_X)\npreds <- predict(\n  object = model_genlasso,\n  Xnew = model.matrix(~ ., df_test_X_nm),\n  lambda = lambda_gen #λの値を引数lambdaに与えます。\n)\npreds <- c(preds$fit)# 予測値を取り出します。\n\n#精度評価のため、RMSEを計算します。\n.rmse <- round(yardstick::rmse_vec(df_test_y, preds), 3)\n\n#横軸に目的変数の実測値、縦軸に予測値をプロットします。\nggplot(mapping = aes(x = df_test_y, y = preds)) +\n  geom_point() +\n  ggtitle(paste(\"Lasso @\", lambda_gen, \" | RMSE:\", .rmse))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/basic_predict-1.png){width=576}\n:::\n:::\n\n\n\n\n### λのチューニング\n\n予測モデルとして用いる場合、\nラッソ回帰における $\\lambda$ を決定する方法として交差検証法（CV:Cross Validation）が考えられます。\n今回はこれを実装してみましょう。\n\n本パッケージの特徴として、1回のモデル構築で全てのλに対する解が得られるため、\nλの候補数だけモデル構築を繰り返す必要はありません。\n例えば 5-fold 交差検証法の場合は、累計5回モデル構築を行えば十分です。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\n#k-fold 交差検証法に用いるデータセットを用意します。\n#学習用データを5等分したうえで、\n#そのうち4個（分析セット）でモデル構築 → 1個（検証セット）で精度確認　を5回繰り返すものですが、\n#以下の関数により、分析セット・検証セットの組を計5組用意することができます。\nsplits_cv <- rsample::vfold_cv(df_train, v = 5)\n\n#各foldにおける予測モデルを格納するリスト\nmodels_cv <- list()\n#各fold, λにおける結果を格納するデータフレーム\nresults_cv <- tibble::tibble(id = character(), lambda = numeric(), rmse = numeric())\n#λの候補を設定します。\nlambdas <- c(0, 10^(seq(-100, 0, 1)*3/100)) * nrow(df_train)\n\n#5回モデル構築を繰り返します。\nfor(i in 1:nrow(splits_cv)){\n  #i番目の分析セットを抽出します。\n  split <- splits_cv$splits[[i]]\n  df_analysis <- rsample::analysis(split)\n  df_analysis_nm <- recp_nm |> recipes::bake(new_data = df_analysis)\n  df_analysis_X_nm <- dplyr::select(df_analysis_nm, -medv)\n  df_analysis_y <- df_analysis$medv\n\n  #i版目の分析セットでモデルを構築し、出来上がったモデルをリストに格納します。\n  models_cv[[splits_cv$id[[i]]]] <- \n    genlasso(y = df_analysis_y,\n             X = model.matrix(~ ., df_analysis_X_nm), \n             D = D)\n}\n```\n:::\n\n\n\n\n構築した5つのモデルに対して、事前に用意したλの候補に対する精度評価を行います。\n評価指標（ここではRMSEを使用します）の平均が良好なλを、最終的なλとして採用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:nrow(splits_cv)){\n  #i番目の検証セットを抽出します。\n  split <- splits_cv$splits[[i]]\n  df_assessment <- rsample::assessment(split)\n  df_assessment_nm <- recp_nm |> recipes::bake(new_data = df_assessment)\n  df_assessment_X_nm <- dplyr::select(df_assessment_nm, -medv)\n  df_assessment_1X_nm <- model.matrix(~ ., df_assessment_X_nm)\n  df_assessment_y <- df_assessment$medv\n  \n  #i番目のモデルに対して、検証セットにおける予測精度を確認します。\n  model <- models_cv[[splits_cv$id[[i]]]]\n  \n  #λは事前に設定した候補(lambdas)分だけ検証します。\n  for(lambda in lambdas){\n    preds <- predict(\n      object = model,\n      Xnew = df_assessment_1X_nm,\n      lambda = lambda\n    )\n    preds <- c(preds$fit)\n    .rmse <- yardstick::rmse_vec(df_assessment_y, preds)\n    \n    #評価結果をデータフレームに記録します。\n    results_cv <- dplyr::bind_rows(\n      results_cv,\n      tibble::tibble(id = splits_cv$id[[i]],\n                     lambda = lambda,\n                     rmse = .rmse))\n  }\n}\n\n#各λでRMSEの平均値を計算し、昇順にソートします。\nresults_tmp <- results_cv |>\n  dplyr::group_by(lambda) |>\n  dplyr::summarise(mean_rmse = mean(rmse)) |>\n  dplyr::arrange(mean_rmse)\n\n#結果を表示します。\nresults_tmp |> head()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"lambda\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"mean_rmse\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"6.436343\",\"2\":\"4.861531\"},{\"1\":\"6.896666\",\"2\":\"4.861553\"},{\"1\":\"6.006745\",\"2\":\"4.861584\"},{\"1\":\"5.605821\",\"2\":\"4.861658\"},{\"1\":\"7.389911\",\"2\":\"4.861720\"},{\"1\":\"5.231656\",\"2\":\"4.861749\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\nこのλにおける予測精度は次のとおりです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda_best <- results_tmp$lambda[[1]]\n\npreds <- predict(\n  object = model_genlasso,\n  Xnew = model.matrix(~ ., df_test_X_nm),\n  lambda = lambda_best\n)\npreds <- c(preds$fit)\n.rmse <- round(yardstick::rmse_vec(df_test_y, preds), 3)\nggplot(mapping = aes(x = df_test_y, y = preds)) +\n  geom_point() +\n  ggtitle(paste(\"Lasso @\", round(lambda_best, 3), \" | RMSE:\", .rmse))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/tuning_result-1.png){width=576}\n:::\n:::\n\n\n\n\n### 1次元フューズドラッソ\n\n#### ビニングを行う場合 {#sec-genlasso-fusedlasso}\n\nフューズドラッソとは罰則項を$\\lambda \\sum_{i=1}^{k-1} | \\beta_{i+1} - \\beta_{i}  |$ としたもののことで、\n隣接した説明変数同士の係数が同じ値に近づくような作用を与えます。\n\n今回は例として、説明変数`lstat`と目的変数の関係に着目することとします。\n\n横軸に`lstat`[^normalized]、縦軸に目的変数をとって散布図を描くと次のとおりです。\n\n[^normalized]: 以下断りが無ければ、@sec-genlasso-basic で標準化したものです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda <- lambda_best\nggplot(mapping = aes(x = df_train_X_nm$lstat, y = df_train_y)) +\n  geom_point() +\n  ggtitle(paste(\"Lasso @\", round(lambda, 3), \" | RMSE:\", .rmse))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso_display_lstat-1.png){width=576}\n:::\n:::\n\n\n\n\nこの2変数の関係を、フューズドラッソにより要約して捉えることを考えましょう。\n\nまず、`lstat`の値を離散化します。\n\n値域をいくつかの領域（ビン）に区分し、\nそれぞれの領域に属しているときに1、そうでないときに0というダミー変数をビンの数だけ作成します。\nなお、このような処理をビニングといいます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX_raw <- df_train_X_nm$lstat\n#領域を区切る点を指定します。\nbreaks <- seq(min(X_raw), max(X_raw), length.out = 21) #20等分\n\n#各行に対する、ダミー変数化の処理をを定義します。\nbreaks_r <- c(breaks, +Inf)\nfn_discretize <- function(x) {\n  as.integer(x >= breaks_r[-length(breaks_r)] & x < breaks_r[-1])\n}\n#この処理を、全ての行で同時に行います。\nX <- sapply(X_raw, fn_discretize)\n#行と列が入れ替わってしまうため、転置します。\nX <- t(X)\n\n#もともとのlstatと、各ダミー変数の値を横に並べて表示します。\nhead(cbind(X_raw, X))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           X_raw                                          \n[1,]  2.53339277 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0\n[2,]  0.09071772 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[3,] -0.76778399 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[4,] -0.07986406 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[5,] -0.72024481 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[6,] -0.88523374 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\n\n同じことを後で評価用データにも行う必要があるので、関数化しておきます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn_getdisclstat <- function(df_X_nm){\n  X <- df_X_nm$lstat\n  X <- sapply(X, fn_discretize)\n  t(X)\n}\n```\n:::\n\n\n\n\n\n計画行列はこれで完成です。\nフューズドラッソに対応する $D$ は`getD1d`関数で取得できるため、\n次のように指定することで実行可能ですが……\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_fusedlasso1d <- genlasso(y = df_train_y, X = X, D = getD1d(ncol(X)))\n```\n:::\n\n\n\n\nフューズドラッソの場合はより実行が簡単で、かつ効率的なアルゴリズムを用いることが出来る\n`fusedlasso1d`関数が用意されています。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_fusedlasso1d <- fusedlasso1d(y = df_train_y, X = X)\n```\n:::\n\n\n\n\n`plot`関数により、フューズドラッソの係数（要約した結果）をプロットすることができます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(model_fusedlasso1d, lambda = lambda)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso_plot-1.png){width=576}\n:::\n:::\n\n\n\n\n\n予測の方法などは`genlasso`関数を用いた場合と同じです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda_fused <- 0.027 * nrow(df_train)\n\npreds <- predict(\n  object = model_fusedlasso1d,\n  Xnew = fn_getdisclstat(df_train_X_nm),\n  lambda = lambda_fused\n)\npreds <- data.frame(lstat = df_train_X_nm$lstat, y = df_train_y, source = \"actual\") |>\n  rbind(data.frame(lstat = df_train_X_nm$lstat, y = c(preds$fit), source = \"model\"))\nggplot(preds, mapping = aes(x = lstat, y = y, color = source)) +\n  geom_point() +\n  ggtitle(paste(\"1 Var Fused Lasso @\", round(lambda_fused, 3)))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/unnamed-chunk-2-1.png){width=576}\n:::\n:::\n\n\n\n\n\nこの1変数だけの予測モデルの評価用データにおける予測精度を確認すると次のとおりです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreds <- predict(\n  object = model_fusedlasso1d,\n  Xnew = fn_getdisclstat(df_test_X_nm),\n  lambda = lambda\n)\npreds <- c(preds$fit)\n.rmse <- round(yardstick::rmse_vec(df_test_y, preds), 3)\nggplot(mapping = aes(x = df_test_y, y = preds)) +\n  geom_point() +\n  ggtitle(paste(\"1 Var Fused Lasso @\", lambda, \" | RMSE:\", .rmse))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso_predict-1.png){width=576}\n:::\n:::\n\n\n\n\n#### ビニングを行わない場合\n\nラッソ回帰の場合はモデルの係数の個数が非常に多くとも問題ないという特徴があるため、\nビニングしないでそのままのデータを用いることも考えられます。\n\n`X`を省略した場合は`y`の長さと同じ数だけの説明変数が用意されます。\nこのとき、「隣り合う説明変数」を正しく認識させるため、\n`y`を元の説明変数の順序で並び替えておきます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#見た目がそれなりに滑らかになるλに設定します。\nlambda_fused2 <- 0.3 * nrow(df_train)\n#説明変数の順序で並べ替えます。\ny_sorted <- sort_by(df_train_y, X_raw)\n#モデルを構築します。\nmodel_fusedlasso1d_a <- fusedlasso1d(y = y_sorted)\n#構築したモデルと元のデータを重ねてプロットします。\nplot(model_fusedlasso1d_a, lambda = lambda_fused2)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso1d-1.png){width=576}\n:::\n:::\n\n\n\n\n引数`pos`で位置情報を与えることも可能ですが、\nフューズドラッソの場合は特に計算結果に影響しません。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#昇順という制限があるため、ソートしておきます。\npos <- sort(X_raw)\n#重複なしという制限があるため、重複している箇所はわずかに数値をずらします。\npos <- pos + seq(0, 1e-7, length.out = length(X_raw))\n\nmodel_fusedlasso1d_ap <- fusedlasso1d(y = y_sorted, pos = pos)\nplot(model_fusedlasso1d_ap, lambda = lambda_fused2)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso1d_pos-1.png){width=576}\n:::\n:::\n\n\n\n\n### トレンドフィルター\n\n罰則項を $\\lambda \\sum_{i=1}^{k-2} | (\\beta_{i+2} - \\beta_{i+1}) - (\\beta_{i+1} - \\beta_{i}) |$ とすることで、\n隣接した「説明変数の差」が同じ値に近づくような作用を与えることができます。\n一般化ラッソ回帰問題にて $D$ を次のように設定することでこの問題に帰着します。\n\n$$\nD = \\begin{bmatrix}\n1 & -2 & 1 & 0 & \\cdots & 0 & 0 & 0\\\\\n0 & 1 & -2 & 1 & \\cdots & 0 & 0 & 0 \\\\\n &  & \\vdots &  & \\ddots & & \\vdots &  \\\\\n0 & 0 & 0 & 0 & \\cdots & 1 & -2 & 1 \\\\\n\\end{bmatrix}\n$$\n\n「なるべく傾きの変わらない（少ない数の）直線でつなぐ」ことで、長期的なトレンドを抽出することができます。\n\n`genlasso`関数にて引数`D`を`getDtfPosSparse`関数で与えることでも実行できますが、\nより実行が簡単で、かつ効率的なアルゴリズムを用いることが出来る\n`trendfilter`関数が用意されています。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_trendfilter1d<- trendfilter(y = y_sorted, ord = 1)\nplot(model_trendfilter1d, lambda = lambda_fused2)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/trendfilter_1d-1.png){width=576}\n:::\n:::\n\n\n\n\nさらに高階の差分を考えることもできます。\n\nつまり、罰則項を\n$\\lambda \\sum_{i=1}^{k-3} | \\beta_{i+3} - 3\\beta_{i+2} + 3\\beta_{i+1} - \\beta_{i} |$\nとすることで「なるべく少ない数の放物線でつなぐ」（2次のトレンドフィルター）、\n罰則項を\n$\\lambda \\sum_{i=1}^{k-4} | \\beta_{i+4} - 4\\beta_{i+3} + 6\\beta_{i+2} - 4\\beta_{i+1} + \\beta_{i}|$\nとすることで「なるべく少ない数の3次曲線でつなぐ」（3次のトレンドフィルター）という回帰問題とすることができます。\n\n引数`ord`を変更することでこのような計算を行うことができます。\nなお、ゼロの場合はフューズドラッソになります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_trendfilter2d<- trendfilter(y = y_sorted, ord = 2)\nplot(model_trendfilter2d, lambda = lambda_fused2)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/trendfilter_2d3d-1.png){width=576}\n:::\n\n```{.r .cell-code}\nmodel_trendfilter3d<- trendfilter(y = y_sorted, ord = 3)\nplot(model_trendfilter3d, lambda = lambda_fused2)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/trendfilter_2d3d-2.png){width=576}\n:::\n:::\n\n\n\n\n各点の位置`pos`を与えることも可能です。\n`ord`が1以上の場合は、罰則項の係数が隣り合う点の距離に応じて調整される（「1/距離」倍だけ補整される）ため、\n結果が前述したものとは異なってきます。\n\nただし、今回のデータのように点が密集している箇所がある場合、あまり意味のある結果にはなりません。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_trendfilter1d_p<- trendfilter(y = y_sorted, ord = 1, pos = pos)\nplot(model_trendfilter1d_p, lambda = lambda_fused2)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/trendfilter_pos-1.png){width=576}\n:::\n\n```{.r .cell-code}\nmodel_trendfilter2d_p<- trendfilter(y = y_sorted, ord = 2, pos = pos)\nplot(model_trendfilter2d_p, lambda = lambda_fused2)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/trendfilter_pos-2.png){width=576}\n:::\n\n```{.r .cell-code}\nmodel_trendfilter3d_p<- trendfilter(y = y_sorted, ord = 3, pos = pos)\nplot(model_trendfilter3d_p, lambda = lambda_fused2)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/trendfilter_pos-3.png){width=576}\n:::\n:::\n\n\n\n\nなお、この`trendfilter`に対しては\n交差検証法（CV）でλをチューニングする`cv.trendfilter`という関数が存在しています。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_trendfilter0d<- trendfilter(y = y_sorted, ord = 0)\ncv <- cv.trendfilter(model_trendfilter0d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFold 1 ... Fold 2 ... Fold 3 ... Fold 4 ... Fold 5 ... \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(model_trendfilter0d, lambda=cv$lambda.min, \n     main=paste0(\"lambda = \", cv$lambda.min))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/trendfilter_cv-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### 2次元フューズドラッソ\n\n2次元の数値データに対しては、\n水平方向と垂直方向の両方の隣接関係に対する係数の差分を罰則とするよう $D$ を設定することで、\n例えば画像のノイズ除去のような処理を行うこともできます。\n\nこのような設定でのフューズドラッソ回帰を行う関数`fusedlasso2d`が用意されています。\n実際に、この2次元フューズドラッソにより画像のノイズ除去を行ってみましょう。\n\nまず、サンプル画像を読み込みます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg_raw <- png::readPNG(system.file(\"img\", \"Rlogo.png\", package=\"png\"))\nstr(img_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num [1:76, 1:100, 1:4] 0 0 0 0 0 0 0 0 0 0 ...\n```\n\n\n:::\n:::\n\n\n\n\nサンプルデータは、縦76ピクセル、横100ピクセルの画像ファイルです。\n各ピクセルはRGB（赤、緑、青）の3色の強さと、\n不透明度を表すアルファチャンネルを合わせた4つのデータの組で表されるため、\n縦ピクセル数×横ピクセル数×4 の3次元配列となってデータが格納されています。\n\nこれをRで描画するためには`rasterImage`関数を用います。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn_plotimg <- function(img, ...){\n  img_width <- dim(img)[2]\n  img_height <- dim(img)[1]\n  \n  par_old <- par(mar=c(1, 1, 1, 1)) #余白の調整\n  if (img_width > img_height){\n    plot(0:img_width, type='n', xlab = \"\", ylab = \"\", axes = FALSE, ...)\n    rasterImage(img, 0, (img_width - img_height)/2, img_width, \n                img_height + (img_width - img_height)/2)\n  }else{\n    plot(0:img_height, type='n', xlab = \"\", ylab = \"\", axes = FALSE, ...)\n    rasterImage(img, (img_height - img_width)/2, 0, \n                img_width + (img_height - img_width)/2, img_height)\n  }\n  par(par_old) #余白をもとに戻す\n}\nfn_plotimg(img_raw, main = \"Raw Image\")\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso2d_plotimg-1.png){width=384}\n:::\n:::\n\n\n\n\n\nこれに、正規分布に基づくノイズを付加してみます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\nimg_noisy <- img_raw\nimg_noisy <- img_noisy + array(rnorm(length(img_noisy), sd = 0.3), dim(img_noisy))\nimg_noisy[img_noisy > 1] <- 1\nimg_noisy[img_noisy < 0] <- 0\nfn_plotimg(img_noisy, main = \"Noisy Image\")\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso2d_noise-1.png){width=384}\n:::\n:::\n\n\n\n\nRGB、アルファチャンネルの4チャンネルそれぞれに対して、\n2次元フューズドラッソによるノイズ除去を試みます。\n\nただし、回帰モデルの説明変数の数が「縦ピクセル数×横ピクセル数」となることから、\nこの画像全体に対して1つのモデルを構築しようとするとモデル構築に時間がかかってしまうため、\n画像の一部を切り出してその部分にのみ処理を行うこととします。\n\nλによってノイズと判断して除去される凸凹が変化することが分かります。\n今回の例の場合、0.1～0.3あたりがちょうど良いようです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#後で全体のノイズ除去を試みるにあたり、\n#区画を size_window × size_window ピクセルずつに分けることとします。\nsize_window <- 15\n#ただし、区画の境界で不自然な線が現れないよう、\n#区画の右側と下側は size_pad ピクセル分広くとった領域でモデルを構築します。\nsize_pad <- 3\n\n#モデルを格納するリストを用意します。\nmodels_fusedlasso2d <- list()\n\nc <- 1 #色のチャンネル\ni <- 2 #Y軸方向のインデックス\nj <- 3 #X軸方向のインデックス\n\n#ノイズ除去を行う領域(上下左右の端)を設定します。\nx1 <- (j - 1) * size_window + 1\ny1 <- (i - 1) * size_window + 1\nx2 <- min(x1 + size_window + size_pad - 1, dim(img_raw)[2])\ny2 <- min(y1 + size_window + size_pad - 1, dim(img_raw)[1])\n\n#cat(\"i = \",i, \", j = \",j, \", c = \",c,\"\\n\")\n#全体の画像から対象領域を取り出します。\nimg_tmp <- img_noisy[y1:y2,x1:x2,c]\n\nmodels_fusedlasso2d[[i]] <- list()\nmodels_fusedlasso2d[[i]][[j]] <- list()\n#2次元フューズドラッソ回帰モデルを構築します。\nmodels_fusedlasso2d[[i]][[j]][[c]] <- fusedlasso2d(y = img_tmp)\n\n#2x2で画像を表示します。\npar_old <- par(mfrow = c(2, 2))\nfn_plotimg(img_raw[y1:y2,x1:x2,c], main = \"Raw Image\")\nfn_plotimg(img_noisy[y1:y2,x1:x2,c], main = \"Noisy Image\")\n\n#各λの結果を並べて表示します。\nfor(lambda in c(0.01, 0.03, 0.1, 0.3, 1, 3)){\n  co <- coef(models_fusedlasso2d[[i]][[j]][[c]], lambda = lambda)\n  img_processed_tmp <- array(co$beta, c(dim(img_tmp)[1], dim(img_tmp)[2]))\n  fn_plotimg(img_processed_tmp, main = paste0(\"Processed Image, lambda = \",lambda))\n}\n#描画設定をもとに戻します。\npar(par_old)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso2d_denoise-1.png){width=576}\n:::\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso2d_denoise-2.png){width=576}\n:::\n:::\n\n\n\n\n全体にこれを適用すると次のようになります。\n\n今回の例のようなそれほど大きくない画像でも数十分程度の時間がかかるため、実行時は注意してください。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodels_fusedlasso2d <- list()\nni <- ((dim(img_raw)[1]-size_pad-1) %/% size_window + 1)\nnj <- ((dim(img_raw)[2]-size_pad-1) %/% size_window + 1)\nfor(i in 1:ni){\n  models_fusedlasso2d[[i]] <- list()\n  for(j in 1:nj){\n    models_fusedlasso2d[[i]][[j]] <- list()\n    \n    x1 <- (j - 1) * size_window + 1\n    y1 <- (i - 1) * size_window + 1\n    x2 <- min(x1 + size_window + size_pad - 1, dim(img_raw)[2])\n    y2 <- min(y1 + size_window + size_pad - 1, dim(img_raw)[1])\n    for(c in 1:dim(img_raw)[3]){\n      #cat(\"i = \",i, \", j = \",j, \", c = \",c,\"\\n\")\n      img_tmp <- img_noisy[y1:y2,x1:x2,c]\n      models_fusedlasso2d[[i]][[j]][[c]] <- fusedlasso2d(y = img_tmp)\n    }\n  }\n}\n\npar_old <- par(mfrow = c(2, 2))\nfn_plotimg(img_raw, main = \"Raw Image\")\nfn_plotimg(img_noisy, main = \"Noisy Image\")\nimgs_processed <- list()\nfor(lambda in c(0.01, 0.03, 0.1, 0.3, 1, 3)){\n  img_processed <- array(1, dim = dim(img_raw))\n  for(c in 1:dim(img_raw)[3]){#\n    img_processed_tmp <- array(NA, dim = c(dim(img_raw)[1:2], ni*nj))\n    for(i in 1:ni){\n      for(j in 1:nj){\n        x1 <- (j - 1) * size_window + 1\n        y1 <- (i - 1) * size_window + 1\n        x2 <- min(x1 + size_window + size_pad - 1, dim(img_raw)[2])\n        y2 <- min(y1 + size_window + size_pad - 1, dim(img_raw)[1])\n        co <- coef(models_fusedlasso2d[[i]][[j]][[c]], lambda = lambda)\n        img_processed_tmp[y1:y2,x1:x2,nj*(i-1)+j] <- array(co$beta, c(y2-y1+1, x2-x1+1))\n      }\n    }\n    #size_padによって広げた箇所は複数モデルの結果があるため、これらは単純平均します。\n    img_tmp <- apply(img_processed_tmp, 1:2, mean, na.rm = T)\n    img_tmp[is.na(img_tmp)] <- 1\n    img_processed[,,c] <- img_tmp\n  }\n  imgs_processed[[as.character(lambda)]] <- img_processed\n  fn_plotimg(imgs_processed[[as.character(lambda)]], main = paste0(\"Processed Image, lambda = \",lambda))\n}\npar(par_old)\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso2d_denoise_all_output-1.png){width=576}\n:::\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/fusedlasso2d_denoise_all_output-2.png){width=576}\n:::\n:::\n\n\n\n\n\n## 他パッケージとの比較\n\n### glmnet\n\nglmnet パッケージは正則化GLMのモデリングに用いられるパッケージです。\n\ngenlasso パッケージと比較すると次のような特徴があります。\n\n- glmnet パッケージは**GLM**を取り扱うもので、よく使われるリンク関数や残差分布（ガウス分布以外）に対応しています。genlasso パッケージは通常の線形回帰問題のみです。\n- genlasso パッケージ利用時は、標準化や切片項の追加を自分で行う必要がありましたが、glmnet パッケージでは自動で行えます。\n- glmnet パッケージは各観測に対する重み付けにも対応しています。\n- glmnet パッケージも genlasso パッケージ同様、一度の学習で全てのλに対する解を得ることができます。\n- glmnet パッケージは、交差検証法（CV）による**λのチューニング**にも対応しています。genlasso パッケージの場合、同機能があるのはトレンドフィルターのみです。\n- glmnet パッケージは、ラッソ正則化のみならず、**リッジ**（2 - ノルムによる罰則項）や**エラスティックネット**（ラッソとリッジ両方の罰則項を持つもの）にも対応しています。一方、$D\\beta$ の形の罰則項には対応していません。\n\nこのように、予測モデリングに便利な機能が多数備わっているため、\nglmnetパッケージが使用できる状況（罰則項が通常のラッソ回帰である場合）ではこちらの方が有用なケースが多いでしょう。\n\n実際、 @sec-genlasso-basic 節で述べた例は（λのチューニングも含めて）\n次のとおり簡単に記述することができます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glmnet)\n#CVで最適なλを求めながらモデルを構築します。\nset.seed(42)\nmodel_cv.lasso <- glmnet::cv.glmnet(\n  #matrix型である必要があるため変換します。\n  x = as.matrix(df_train_X_nm),\n  y = df_train_y,\n  #正則化項のαを指定（1：ラッソ、0：リッジ）します。\n  alpha = 1, \n  #CVの分割数を指定します。\n  nfolds = 5 \n)\n#最適なλを抽出します。\nlambda_glm <- model_cv.lasso$lambda.min |> round(3)\n\n#予測精度の確認のため、評価用データでの予測値を取得します。\npreds <- predict(\n  object = model_cv.lasso,\n  #matrix型である必要があるため変換します。\n  newx = as.matrix(df_test_X_nm), \n  #λは引数sに与えます（lambdaではありません）。\n  s = lambda_glm\n) |> c()\n.rmse <- round(yardstick::rmse_vec(df_test_y, preds), 3)\nggplot(mapping = aes(x = df_test_y, y = preds)) +\n  geom_point() +\n  ggtitle(paste(\"Lasso @\", lambda_glm, \" | RMSE:\", .rmse))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/glmnet-1.png){width=576}\n:::\n\n```{.r .cell-code}\n#λごとのCVの結果をプロットします。\nplot(model_cv.lasso)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/glmnet-2.png){width=576}\n:::\n\n```{.r .cell-code}\n#λ別の係数プロット（解パス）をプロットします。\nplot(model_cv.lasso$glmnet.fit, \"lambda\")\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/glmnet-3.png){width=576}\n:::\n\n```{.r .cell-code}\n#指定したλにおける係数を出力します。\n#genlassoの係数とほぼ同等となっていることがわかります。\ncoef(model_cv.lasso$glmnet.fit, s = c(0.01, 0.1, 1, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n14 x 4 sparse Matrix of class \"dgCMatrix\"\n                     s1         s2          s3       s4\n(Intercept) 22.44828496 22.4482850 22.44828496 22.44828\ncrim        -1.07290435 -0.7884986  .           .      \nzn           0.81966961  0.4262189  .           .      \nindus       -0.03945084 -0.1777379  .           .      \nchas         0.47170645  0.4563839  .           .      \nnox         -2.10738128 -1.6769990  .           .      \nrm           2.50046418  2.6201820  2.54685806  .      \nage         -0.16251918  .          .           .      \ndis         -3.23779431 -2.4650921  .           .      \nrad          2.61941760  1.2670168  .           .      \ntax         -1.72933402 -0.5630096  .           .      \nptratio     -2.15099633 -2.0243315 -1.22146843  .      \nblack        0.68711370  0.6314864  0.05446536  .      \nlstat       -3.84813288 -3.8995978 -3.66282065  .      \n```\n\n\n:::\n:::\n\n\n\n\nなお、glmnet パッケージで最小化される関数は次のようなものです。\n\n\n$$\n\\frac1n\\sum_{i=1}^nw_il\n\\left(y_i, \\beta_0 + \\sum_{j=1}^{k} \\left( x_{ij} \\cdot \\beta_j \\right) \\right)\n + \\lambda \\left[ \\frac{(1-\\alpha)}2 \\| \\beta \\| _2^2 + \\alpha \\| \\beta \\|_1 \\right]\n$$\n\nただし、$\\beta_0$ はモデルの切片項（罰則項のノルムの計算には含まれません）、\n$l(y_i, \\eta_i)$ は $i$ 番目の観測に対する負の対数尤度関数、\n$w = (w_i)_{i=1}^n$ は観測の重みを表すベクトル、\n$\\alpha \\in [0, 1]$ は罰則項の形状を表すハイパーパラメータです。\n\nリンク関数として恒等関数、残差分布としてガウス分布を選ぶと、\n$l(y_i, \\eta_i) = \\frac12 (y_i - \\eta_i)^2$ となり、\nまた切片項 $\\beta_0 = 0$ 、重み $w$ を全て1、$\\alpha = 1$ （ラッソ回帰）とすることで\ngenlasso が最小化する関数と同等の形式になります。\n\n$$\n\\frac1{2n}\\| y - X\\beta \\|_2^2 + \\lambda\\| \\beta \\|_1\n$$\n\nただし、第1項に係数 $1/n$ がかかっている点のみ genlasso のものとは異なっています。\nこれは、第1項が表す残差が観測数に比例して増加する点を補整するためです。\n\nこのため、解として得られる λ のスケールが異なることに注意してください。\n具体的には、genlasso 側の λ が観測数 $n$ に比例して大きくなります [^1]。\n\n[^1]: 本稿ではこれを踏まえて、定数×観測数 の形で λ を指定している箇所が存在します。\n\n\n\n### aglm\n\naglm とは正則化 GLM の変種である**AGLM**（Accurate Generalized Linear Model）\n[@BIB_AGLM_2019_JARIP, @BIB_AGLM_2020] のモデリングを実装したパッケージです。\n\nAGLM は GLM とよく似たモデルですが、\n連続変数に対しては @sec-genlasso-fusedlasso で述べたような\nビニングを伴うフューズドラッソと同等の変換を行います。\nGLM のような加法的モデルであるという性質を維持しながら、\n説明変数と目的変数の間の非線形な関係を表現することが可能になっています。\n\nここでダミー変数化の際に**順序付きダミー変数**（閾値以上なら 1 となるダミー変数）を利用することで、\nフューズドラッソが通常の（罰則項を $\\lambda \\| \\beta \\|$ とする）ラッソ回帰に帰着できるという性質を用いており、\nダミー変数化の処理を行った後の内部の計算処理に glmnet を用いているのが特徴です。\nそのため、前述した glmnet の特徴（利点）がそのまま継承されています。\n\n次のようにすることで、@sec-genlasso-fusedlasso の例を再現するモデルを構築することができます。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aglm)\nmodel_aglm_1v <- aglm(\n  x = df_train_X_nm$lstat,\n  #ビンの端点をfusedlasso1dで使用したものと同じにします。\n  bins_list = list(X1 = breaks), \n  y = df_train_y,\n  add_linear_columns = FALSE,\n  #glmnetで説明変数を標準化しないようにします。\n  standardize = F, \n  #OD化する際に離散化する（線形補間しない）ようにします。\n  OD_type_of_quantitatives = \"J\", \n  alpha = 1 # 正則化項のαパラメーターを指定（1：ラッソ、0：リッジ）\n)\n#λはgenlassoの例から流用します。\nlambda_aglm <- lambda_best / nrow(df_train_X)\n\n#予測精度の確認のため、評価用データでの予測値を取得します。\npreds <- predict(\n  object = model_aglm_1v,\n  newx = df_test_X_nm$lstat,\n  s = lambda_aglm\n) |> c()\n.rmse <- round(yardstick::rmse_vec(df_test_y, preds), 3)\nggplot(mapping = aes(x = df_test_y, y = preds)) +\n  geom_point() +\n  ggtitle(paste(\"1 Var Fused Lasso by AGLM @\", round(lambda_aglm, 3),\n                \" | RMSE:\", .rmse))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/aglm_1v-1.png){width=576}\n:::\n\n```{.r .cell-code}\n#関数の形をプロットします。\npar(mar = c(4, 4, 1, 1)) # プロット領域中の余白を調整\nplot(model_aglm_1v, verbose = FALSE, vars = NULL, s = lambda_aglm, ask = FALSE)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/aglm_1v-2.png){width=576}\n:::\n:::\n\n\n\n\n\nこれは説明変数 `lstat` にのみ着目した1変数のモデルでしたが、\n全変数を説明変数としてモデルを構築すると次のとおりです[^2]。\n\n[^2]: 直上の例での標準化やビンの設定などは genlasso パッケージの結果を再現するために設定したものです。\n      以下の例では再現の必要が無いため、aglm パッケージのデフォルト値に戻しています。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#CVで最適なλを求めながらモデル構築\nset.seed(42)\nmodel_cv.aglm <- cv.aglm(\n  x = df_train_X,\n  y = df_train_y,\n  add_linear_columns = FALSE,\n  alpha = 1, # 正則化項のαパラメーターを指定（1：ラッソ、0：リッジ）\n  nfolds = 5 # クロスバリデーションの分割数を指定\n)\nlambda_aglm_best <- model_cv.aglm@lambda.min |> round(3)\n```\n:::\n\n\n\n\n非線形な関係を捉えることができているため、\nGLMと比べて予測精度が大幅に向上していることがわかります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#予測精度の確認\npreds <- predict(\n  object = model_cv.aglm,\n  newx = df_test_X,\n  s = lambda_aglm_best\n) |> c() # 行列形式の出力をベクトルに変換\n.rmse <- round(yardstick::rmse_vec(df_test_y, preds), 3)\nggplot(mapping = aes(x = df_test_y, y = preds)) +\n  geom_point() +\n  ggtitle(paste(\"AGLM@\", lambda_aglm_best, \" | RMSE:\", .rmse))\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/aglm_predict-1.png){width=576}\n:::\n:::\n\n\n\n\n\n予測関数は説明変数の1変数関数の和で表現されているので、\n説明変数ごとに予想関数を分けてプロットすることで\n予測関数の形を把握することも可能です。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4, 4, 1, 1)) # プロット領域中の余白を調整\nplot(model_cv.aglm, verbose = FALSE, vars = NULL, \n     s = lambda_aglm_best, ask = FALSE)\n```\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/aglm_plot-1.png){width=576}\n:::\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/aglm_plot-2.png){width=576}\n:::\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/aglm_plot-3.png){width=576}\n:::\n\n::: {.cell-output-display}\n![](genlasso_files/figure-html/aglm_plot-4.png){width=576}\n:::\n:::\n\n\n\n\nこのように AGLM は予測精度と解釈可能性をある程度両立したモデルであり、\nさらに glmnet パッケージの利点を多く継承していることから、\ngenlasso パッケージよりもこちらを利用したほうがよいケースも多いでしょう。\n\n\n## 参考文献\n\n::: {#refs}\n:::\n",
    "supporting": [
      "genlasso_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
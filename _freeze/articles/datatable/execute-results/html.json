{
  "hash": "a22d1f785fa7f0513ac523cb4523571f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"data.table\"\ndate: \"2025-08-01\"\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    fig-width: 6\n    fig-height: 5\n---\n\n\n\n\n\n::: {.cell}\n<style type=\"text/css\">\n.output-jp > code {\n/*一部日本語出力があるチャンクで日本語と英字の幅が揃わずに表示がずれるため、CSSでフォントを変更することで表示を揃える*/\n  font-family: \"ＭＳ ゴシック\";\n}\n</style>\n:::\n\n\n\n\n## パッケージの概要\n\n`data.table`は、R標準の`data.frame`型を拡張した`data.table`型を導入するパッケージです。\n\n大規模なデータの処理に最適化されているほか、添え字部分の記法が大幅に拡張されており、 効果的に活用することで動作速度とコードの可読性を両立することが可能となります。\n\n本稿ではR標準の関数や、`tidyverse`のデータ操作パッケージとして名高い`dplyr`(一部`tidyr`)による操作とも比較しながら、 `data.table`パッケージの使用方法や特徴について解説します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\nlibrary(dplyr) \nlibrary(tidyr) #pivot系のみ使用 \nlibrary(nycflights13) #大規模データの節で使用\nlibrary(microbenchmark) #大規模データの節で使用\nlibrary(rlang) #関数化の節で使用\n```\n:::\n\n\n\n\n## 基本的な使用方法\n\n### ファイルの読み込み・書き込み\n\n`data.table`パッケージを導入すると、高速なデータの読み書きが可能な関数`fread`, `fwrite`が追加されます。\n\nいずれも、デフォルトではcsv形式での読み書きを行います。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ファイルの書き込み\n# fwrite(iris, file = \"../data/iris.csv\")\n\n# ファイルの読み込み\ndt_tmp <- fread(file = \"../data/insurance.csv\", data.table = TRUE)\n\n#data.tableをFALSEにすることでdata.frame型として読み込むことも可能\nhead(dt_tmp) #冒頭を表示\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     age    sex   bmi children smoker    region expenses\n   <int> <char> <num>    <int> <char>    <char>    <num>\n1:    19 female  27.9        0    yes southwest 16884.92\n2:    18   male  33.8        1     no southeast  1725.55\n3:    28   male  33.0        3     no southeast  4449.46\n4:    33   male  22.7        0     no northwest 21984.47\n5:    32   male  28.9        0     no northwest  3866.86\n6:    31 female  25.7        0     no southeast  3756.62\n```\n\n\n:::\n:::\n\n\n\n\n### `data.table`型変数の作成\n\n`data.table`型としてデータを読み込むには、前述の`fread`関数を用いるほかにも、`data.frame`型など他の型から変換する方法もあります。 通常は`as.data.table`関数を使用すればよいでしょう。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- iris\ndt <- as.data.table(df)\n\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.table\" \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n`data.table`関数で直接生成することもできます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_is <- data.table(\n  配当方式 = c(\"有配\",\"有配\",\"準有配\",\"無配\",\"無配\",\"無配\"),\n  商品種類コード = 1:6,\n  件数 = c(10, 16, 48, 176, 190, 15),\n  特約1件数 = c(10, 0, 24, 110, 30, 12),\n  特約2件数 = c(0, 0, 0, 0, 14, 0),\n  主契約保険金額 = c(100, 60, 240, 69, 1931, 300),\n  特約1保険金額 = c(100, 0, 24, 59, 3140, 240),\n  特約2保険金額 = c(0, 0, 0, 0, 156, 0)\n)\ndt_is\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   配当方式 商品種類コード  件数 特約1件数 特約2件数 主契約保険金額\n     <char>          <int> <num>     <num>     <num>          <num>\n1:     有配              1    10        10         0            100\n2:     有配              2    16         0         0             60\n3:   準有配              3    48        24         0            240\n4:     無配              4   176       110         0             69\n5:     無配              5   190        30        14           1931\n6:     無配              6    15        12         0            300\n   特約1保険金額 特約2保険金額\n           <num>         <num>\n1:           100             0\n2:             0             0\n3:            24             0\n4:            59             0\n5:          3140           156\n6:           240             0\n```\n\n\n:::\n:::\n\n\n\n\n### 添え字の仕様\n\n`data.table`型の記法は`data.frame`型の記法を自然に拡張したものであるため、`変数[行, 列]`という記法はどちらも同じように使用することが出来ます。\n\n細かな差異として、`data.frame`型の場合は`変数[行, 列]`で参照した結果が `data.frame`型ではなくなる(ベクトルや値になる)ことがありますが、 `data.table`型では一貫して`data.table`型のまま取り出されます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##3行目だけを抽出\ndf[3, ] #data.frameのまま\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n3          4.7         3.2          1.3         0.2  setosa\n```\n\n\n:::\n\n```{.r .cell-code}\ndt[3, ] #data.tableのまま\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <num>       <num>        <num>       <num>  <fctr>\n1:          4.7         3.2          1.3         0.2  setosa\n```\n\n\n:::\n\n```{.r .cell-code}\n##\"Sepal.Width\"の列だけを抽出\nhead(df[, \"Sepal.Width\"]) #ベクトルになる\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.5 3.0 3.2 3.1 3.6 3.9\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(dt[, \"Sepal.Width\"]) #data.tableのまま\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Width\n         <num>\n1:         3.5\n2:         3.0\n3:         3.2\n4:         3.1\n5:         3.6\n6:         3.9\n```\n\n\n:::\n\n```{.r .cell-code}\n##3行目, \"Sepal.Width\"の列だけを抽出\ndf[3, \"Sepal.Width\"] #値になる\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.2\n```\n\n\n:::\n\n```{.r .cell-code}\ndt[3, \"Sepal.Width\"] #data.tableのまま\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Width\n         <num>\n1:         3.2\n```\n\n\n:::\n\n```{.r .cell-code}\ndt[[3, \"Sepal.Width\"]] #data.tableでも、括弧を2重にすると値にできる\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.2\n```\n\n\n:::\n:::\n\n\n\n\nちなみに、この`data.frame`の一貫性のない挙動については`tibble`に変換することでも解決できます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_tbl <- tibble::as_tibble(df)\nclass(df_tbl)\n\nhead(df_tbl[, \"Sepal.Width\"]) #データフレームのまま\ndf_tbl[3, \"Sepal.Width\"] #データフレームのまま\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n# A tibble: 6 × 1\n  Sepal.Width\n        <dbl>\n1         3.5\n2         3  \n3         3.2\n4         3.1\n5         3.6\n6         3.9\n# A tibble: 1 × 1\n  Sepal.Width\n        <dbl>\n1         3.2\n```\n\n\n:::\n:::\n\n\n\n\nただし、本稿の趣旨から逸れるため、今後`tibble`については触れません。\n\n特定の列のみを取り出すには`変数[行, 列]`記法のほかにも`変数$列名`や`変数[[\"列名\"]]`記法もあります。 この場合、どちらの型でもベクトルで取り出されます。\n\n※データフレームは同じ長さのベクトルを要素にもつ名前付きリストであるため、リストから要素を取り出すときと同じ動作です。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##Sepal.Widthの列だけを抽出\nhead(df$Sepal.Width)\nhead(dt$Sepal.Width)\nhead(df[[\"Sepal.Width\"]])\nhead(dt[[\"Sepal.Width\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.5 3.0 3.2 3.1 3.6 3.9\n[1] 3.5 3.0 3.2 3.1 3.6 3.9\n[1] 3.5 3.0 3.2 3.1 3.6 3.9\n[1] 3.5 3.0 3.2 3.1 3.6 3.9\n```\n\n\n:::\n:::\n\n\n\n\nなお、添え字を1つしか与えなかった(`変数[○]`表記)場合は`data.frame`型と`data.table`型で動作が異なるため注意してください。\n\n-   `data.frame`では列を取り出します。リストとしての性質が優先されています。\n-   `data.table`では行を取り出します。`変数[行, 列]`記法の列の省略とみなされます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(df[3]) #列の取り出しになる\nhead(dt[3]) #行の取り出しになる\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Petal.Length\n1          1.4\n2          1.4\n3          1.3\n4          1.5\n5          1.4\n6          1.7\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <num>       <num>        <num>       <num>  <fctr>\n1:          4.7         3.2          1.3         0.2  setosa\n```\n\n\n:::\n:::\n\n\n\n\n### 行・列の取り出し\n\n以下、基本的なデータ操作についてR標準の記法や`dplyr`とも比較しながら説明します。\n\n`data.frame`での列の取り出し方には次のようなものがあります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(df[[\"Sepal.Width\"]]) #1列をベクトルとして取り出し\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.5 3.0 3.2 3.1 3.6 3.9\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(subset(df, select = \"Sepal.Width\")) #1列をデータフレームとして取り出し\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Width\n1         3.5\n2         3.0\n3         3.2\n4         3.1\n5         3.6\n6         3.9\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(df[,c(\"Sepal.Length\", \"Sepal.Width\")]) #複数列をデータフレームとして取り出し\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width\n1          5.1         3.5\n2          4.9         3.0\n3          4.7         3.2\n4          4.6         3.1\n5          5.0         3.6\n6          5.4         3.9\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(df[, !names(df) %in% c(\"Sepal.Length\", \"Sepal.Width\")]) #指定した列以外を取り出し\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Petal.Length Petal.Width Species\n1          1.4         0.2  setosa\n2          1.4         0.2  setosa\n3          1.3         0.2  setosa\n4          1.5         0.2  setosa\n5          1.4         0.2  setosa\n6          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\n\n\n`data.table`型の場合、添え字の部分で特殊な記法が使用可能です。列名を文字列として与えるのではなく、列名そのものを書くことができます。\n\nなお、以降に現れる`.(*)`という記法は`list(*)`の省略形で、添え字などにリストを与えていることに相当します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dt[,Sepal.Width]) #1列をベクトルとして取り出し\nhead(dt[,.(Sepal.Width)]) #1列をdata.tableとして取り出し\nhead(dt[,.(Sepal.Length, Sepal.Width)]) #複数列をdata.tableとして取り出し\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.5 3.0 3.2 3.1 3.6 3.9\n   Sepal.Width\n         <num>\n1:         3.5\n2:         3.0\n3:         3.2\n4:         3.1\n5:         3.6\n6:         3.9\n   Sepal.Length Sepal.Width\n          <num>       <num>\n1:          5.1         3.5\n2:          4.9         3.0\n3:          4.7         3.2\n4:          4.6         3.1\n5:          5.0         3.6\n6:          5.4         3.9\n```\n\n\n:::\n:::\n\n\n\n\n列の除外は`data.frame`と同じ書き方も可能ですが、 `data.table`特有の記法を用いたものでは以下のような方法があります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dt[, !c(\"Sepal.Length\", \"Sepal.Width\")], n = 1) #!は除くという意味\ncols <- c(\"Sepal.Length\", \"Sepal.Width\")\nhead(dt[, !..cols], n = 1) # ..colsとした場合、内部的に上で代入した c(\"Sepal.Length\", \"Sepal.Width\") に置き換えられる\nhead(dt[, setdiff(names(dt), c(\"Sepal.Length\", \"Sepal.Width\")), with = FALSE], n = 1)\n#setdiffは差集合をとる、with = FALSEは選択する列をリストで直接指定するという意味\nhead(dt[,.SD, .SDcols = !c(\"Sepal.Length\", \"Sepal.Width\")], n = 1) #.SDは.SDcolsで指定した列全体を表す特殊記号\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Petal.Length Petal.Width Species\n          <num>       <num>  <fctr>\n1:          1.4         0.2  setosa\n   Petal.Length Petal.Width Species\n          <num>       <num>  <fctr>\n1:          1.4         0.2  setosa\n   Petal.Length Petal.Width Species\n          <num>       <num>  <fctr>\n1:          1.4         0.2  setosa\n   Petal.Length Petal.Width Species\n          <num>       <num>  <fctr>\n1:          1.4         0.2  setosa\n```\n\n\n:::\n:::\n\n\n\n\n`dplyr`においては`select`に対応します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% select(Sepal.Length, Sepal.Width) %>% slice_head(n=2) #指定した列\ndf %>% select(-Sepal.Length, -Sepal.Width) %>% slice_head(n=2) #指定した列以外\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width\n1          5.1         3.5\n2          4.9         3.0\n  Petal.Length Petal.Width Species\n1          1.4         0.2  setosa\n2          1.4         0.2  setosa\n```\n\n\n:::\n:::\n\n\n\n\n次に、特定の条件を満たす行を抽出する方法を見てみましょう。\n\nR標準では次のような書き方になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[df$Sepal.Length < 6.0 & df$Sepal.Width == 3.0 & df$Species %in% c(\"versicolor\", \"virginica\"),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n62           5.9           3          4.2         1.5 versicolor\n67           5.6           3          4.5         1.5 versicolor\n85           5.4           3          4.5         1.5 versicolor\n89           5.6           3          4.1         1.3 versicolor\n96           5.7           3          4.2         1.2 versicolor\n150          5.9           3          5.1         1.8  virginica\n```\n\n\n:::\n:::\n\n\n\n\n`data.table`でも同じ書き方はできますが、`dt$`(変数名)の部分を省略したような書き方も出来ます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[Sepal.Length < 6.0 & Sepal.Width == 3.0 & Species %in% c(\"versicolor\", \"virginica\"),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n          <num>       <num>        <num>       <num>     <fctr>\n1:          5.9           3          4.2         1.5 versicolor\n2:          5.6           3          4.5         1.5 versicolor\n3:          5.4           3          4.5         1.5 versicolor\n4:          5.6           3          4.1         1.3 versicolor\n5:          5.7           3          4.2         1.2 versicolor\n6:          5.9           3          5.1         1.8  virginica\n```\n\n\n:::\n:::\n\n\n\n\n`dplyr`では`filter`を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% filter(Sepal.Length < 6.0 & Sepal.Width == 3.0 & Species %in% c(\"versicolor\", \"virginica\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1          5.9           3          4.2         1.5 versicolor\n2          5.6           3          4.5         1.5 versicolor\n3          5.4           3          4.5         1.5 versicolor\n4          5.6           3          4.1         1.3 versicolor\n5          5.7           3          4.2         1.2 versicolor\n6          5.9           3          5.1         1.8  virginica\n```\n\n\n:::\n:::\n\n\n\n\n### 列の加工・追加\n\n特徴量の加工のような操作を行う場合、R標準では以下のような書き方になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_tmp <- df\ndf_tmp$Sepal.Rate <- df_tmp$Sepal.Length / df_tmp$Sepal.Width #列を追加\ndf_tmp[c(\"Sepal.Length.Sqrt\", \"Sepal.Width.Sqrt\")] <-\n  c(sqrt(df_tmp$Sepal.Length), sqrt(df_tmp$Sepal.Width)) #一度に複数の列を追加\ndf_tmp$Species <- substr(df_tmp$Species, 1, 2) #既存の列を加工\nhead(df_tmp, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Rate\n1          5.1         3.5          1.4         0.2      se   1.457143\n2          4.9         3.0          1.4         0.2      se   1.633333\n3          4.7         3.2          1.3         0.2      se   1.468750\n  Sepal.Length.Sqrt Sepal.Width.Sqrt\n1          2.258318         1.870829\n2          2.213594         1.732051\n3          2.167948         1.788854\n```\n\n\n:::\n:::\n\n\n\n\n`data.table`でも同じ書き方はできますが、`変数[行, 列]`記法の列の箇所で`:=`演算子を用いることでより簡潔に記述できます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_tmp <- copy(dt) #:=演算子がdtに及ばないようにするため\ndt_tmp[, Sepal.Rate := Sepal.Length / Sepal.Width] #列を追加\ndt_tmp[, c(\"Sepal.Length.Sqrt\", \"Sepal.Width.Sqrt\") \n       := .(sqrt(Sepal.Length), sqrt(Sepal.Width))] #一度に複数の列を追加\ndt_tmp[, ':='(Sepal.Length.Sqrt = sqrt(Sepal.Length),\n              Sepal.Width.Sqrt = sqrt(Sepal.Width))]#↑はこのような書き方もある\ndt_tmp[, Species := substr(Species, 1, 2)] #既存の列を加工\nhead(dt_tmp, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Rate\n          <num>       <num>        <num>       <num>  <char>      <num>\n1:          5.1         3.5          1.4         0.2      se   1.457143\n2:          4.9         3.0          1.4         0.2      se   1.633333\n3:          4.7         3.2          1.3         0.2      se   1.468750\n   Sepal.Length.Sqrt Sepal.Width.Sqrt\n               <num>            <num>\n1:          2.258318         1.870829\n2:          2.213594         1.732051\n3:          2.167948         1.788854\n```\n\n\n:::\n:::\n\n\n\n\nただし`:=`演算子を用いるケースでは、単に「変数の代入」でコピーを作成した場合、 **両方に同じ操作が適用されてしまう**(メモリ上の同じものを指している)ので注意してください。 これは大規模データでメモリ消費を抑えられるようにするための意図的な仕様です。\n\nこの現象を避ける(コピー元の方には影響を及ぼさないようにする)ためには、 **`copy`関数で明示的にコピーを作成する**必要があります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_tmp2 <- dt_tmp\ndt_tmp[, Petal.Rate := Petal.Length / Petal.Width] #tmpの方に列を追加\nhead(dt_tmp2, n = 3) #tmp2の方にも追加されている\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Rate\n          <num>       <num>        <num>       <num>  <char>      <num>\n1:          5.1         3.5          1.4         0.2      se   1.457143\n2:          4.9         3.0          1.4         0.2      se   1.633333\n3:          4.7         3.2          1.3         0.2      se   1.468750\n   Sepal.Length.Sqrt Sepal.Width.Sqrt Petal.Rate\n               <num>            <num>      <num>\n1:          2.258318         1.870829        7.0\n2:          2.213594         1.732051        7.0\n3:          2.167948         1.788854        6.5\n```\n\n\n:::\n:::\n\n\n\n\n`dplyr`では`mutate`を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#mutate文の場合敢えて分けて書く必要はないが、説明のため。\ndf_tmp <- df %>% mutate(Sepal.Rate = Sepal.Length / Sepal.Width) #列を追加\n\ndf_tmp <- df_tmp %>% mutate(Sepal.Length.Sqrt = sqrt(Sepal.Length),\n                            Sepal.Width.Sqrt = sqrt(Sepal.Width)) #一度に複数の列を追加\n\ndf_tmp <- df_tmp %>% mutate(Species = substr(Species, 1, 2)) #既存の列を加工\n\nhead(df_tmp, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Rate\n1          5.1         3.5          1.4         0.2      se   1.457143\n2          4.9         3.0          1.4         0.2      se   1.633333\n3          4.7         3.2          1.3         0.2      se   1.468750\n  Sepal.Length.Sqrt Sepal.Width.Sqrt\n1          2.258318         1.870829\n2          2.213594         1.732051\n3          2.167948         1.788854\n```\n\n\n:::\n:::\n\n\n\n\nなお、すでにあるデータを連結する場合は`rbind`や`cbind`も使用できます(R標準と同じであるため割愛)。\n\n### データのソート\n\n`data.frame`, `data.table`ともに、`変数[行, 列]`記法の行の箇所で`order`関数を使用します。\n\n`order`関数は、ベクトルを昇順ソートした時の行番号を返す関数です。`-`を与えることで降順ソートにすることが出来ます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Speciesはfactor型であり、マイナス演算子を直接適用できないため、数値型に一度変換している\nhead(df[order(-as.numeric(df$Species), df$Sepal.Length), ])\n#data.table型ではマイナス演算子をそのまま適用できる\nhead(dt[order(-Species, Sepal.Length), ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n107          4.9         2.5          4.5         1.7 virginica\n122          5.6         2.8          4.9         2.0 virginica\n114          5.7         2.5          5.0         2.0 virginica\n102          5.8         2.7          5.1         1.9 virginica\n115          5.8         2.8          5.1         2.4 virginica\n143          5.8         2.7          5.1         1.9 virginica\n   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n          <num>       <num>        <num>       <num>    <fctr>\n1:          4.9         2.5          4.5         1.7 virginica\n2:          5.6         2.8          4.9         2.0 virginica\n3:          5.7         2.5          5.0         2.0 virginica\n4:          5.8         2.7          5.1         1.9 virginica\n5:          5.8         2.8          5.1         2.4 virginica\n6:          5.8         2.7          5.1         1.9 virginica\n```\n\n\n:::\n:::\n\n\n\n\n`dplyr`では`arrange`関数を使用します。降順ソートを行う場合は`desc`を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% arrange(desc(Species), Sepal.Length) %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          4.9         2.5          4.5         1.7 virginica\n2          5.6         2.8          4.9         2.0 virginica\n3          5.7         2.5          5.0         2.0 virginica\n4          5.8         2.7          5.1         1.9 virginica\n5          5.8         2.8          5.1         2.4 virginica\n6          5.8         2.7          5.1         1.9 virginica\n```\n\n\n:::\n:::\n\n\n\n\n### データのグループ化と集計・要約\n\nあるグループごとに特徴量の平均値を計算したい、といったケースを考えてみましょう。\n\nR標準機能では次のような書き方になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggregate(cbind(Sepal.Length, Sepal.Width) ~  Species, df, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Species Sepal.Length Sepal.Width\n1     setosa        5.006       3.428\n2 versicolor        5.936       2.770\n3  virginica        6.588       2.974\n```\n\n\n:::\n:::\n\n\n\n\n一方`data.table`の場合、添え字の部分に`mean`のような集計関数をそのまま書き込むことができます。 グループ化に使用する列は引数`by`に指定します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[ ,.(Sepal.Length.Mean = mean(Sepal.Length),\n       Sepal.Width.Mean = mean(Sepal.Width)),\n    by = .(Species)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species Sepal.Length.Mean Sepal.Width.Mean\n       <fctr>             <num>            <num>\n1:     setosa             5.006            3.428\n2: versicolor             5.936            2.770\n3:  virginica             6.588            2.974\n```\n\n\n:::\n:::\n\n\n\n\n`dplyr`の場合はグループ化に`group_by`を用いたうえで、`summarize`で集計関数を適用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% group_by(Species) %>%\n  summarize(mean(Sepal.Length), mean(Sepal.Width))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  Species    `mean(Sepal.Length)` `mean(Sepal.Width)`\n  <fct>                     <dbl>               <dbl>\n1 setosa                     5.01                3.43\n2 versicolor                 5.94                2.77\n3 virginica                  6.59                2.97\n```\n\n\n:::\n:::\n\n\n\n\n## 発展的な話題\n\n### 横長と縦長の相互変換(pivot)\n\n#### 横長→縦長\n\nまず、横長(wide型)から縦長(long型)への変換について見てみましょう。\n\nRの標準機能では`reshape`関数が使用できますが、多機能ゆえ適切にパラメータを指定するにはコツが必要です。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long <- reshape(df, direction = \"long\", #縦長への変換モード\n        varying = c(\"Sepal.Length\",\"Sepal.Width\",\"Petal.Length\",\"Petal.Width\"), #縦長に変換したい列を指定\n        timevar = \"VarName\", #縦長に展開するときの、新たに追加されるキー列の名前\n        times = c(\"Sepal.Length\",\"Sepal.Width\",\"Petal.Length\",\"Petal.Width\"), #新たに追加されるキー列の中身(横長時の列名から指定)\n        v.names = \"Value\") #縦長になった結果集約される値が入る列の名前…2列以上も可\nhead(df_long)\naggregate(Value ~ VarName, df_long, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               Species      VarName Value id\n1.Sepal.Length  setosa Sepal.Length   5.1  1\n2.Sepal.Length  setosa Sepal.Length   4.9  2\n3.Sepal.Length  setosa Sepal.Length   4.7  3\n4.Sepal.Length  setosa Sepal.Length   4.6  4\n5.Sepal.Length  setosa Sepal.Length   5.0  5\n6.Sepal.Length  setosa Sepal.Length   5.4  6\n       VarName    Value\n1 Petal.Length 3.758000\n2  Petal.Width 1.199333\n3 Sepal.Length 5.843333\n4  Sepal.Width 3.057333\n```\n\n\n:::\n:::\n\n\n\n\n一方、`data.table`では`melt`を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_long <-  melt(dt, \n                 measure.vars = c(\"Sepal.Length\",\"Sepal.Width\",\"Petal.Length\",\"Petal.Width\"),#縦長に変換したい列を指定\n                 variable.name = \"VarName\", #縦長に展開するときの、新たに追加されるキー列の名前\n                 value.name = \"Value\") #縦長になった結果集約される値が入る列の名前\nhead(dt_long)\ndt_long[ ,mean(Value), by = VarName]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Species      VarName Value\n    <fctr>       <fctr> <num>\n1:  setosa Sepal.Length   5.1\n2:  setosa Sepal.Length   4.9\n3:  setosa Sepal.Length   4.7\n4:  setosa Sepal.Length   4.6\n5:  setosa Sepal.Length   5.0\n6:  setosa Sepal.Length   5.4\n        VarName       V1\n         <fctr>    <num>\n1: Sepal.Length 5.843333\n2:  Sepal.Width 3.057333\n3: Petal.Length 3.758000\n4:  Petal.Width 1.199333\n```\n\n\n:::\n:::\n\n\n\n\nなお、`tidyverse`では`dplyr`ではなく`tidyr`に対応する関数があり、 `pivot_longer`(または`gather`)を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long_tidy <- df %>% \n  tibble::rowid_to_column(\"id\") %>% #あとでもう一度横長に戻すときの基準として入れておく\n  pivot_longer(names_to = \"VarName\", #縦長に展開するときの、新たに追加されるキー列の名前\n                    values_to = \"Value\", #縦長になった結果集約される値が入る列の名前\n                    -c(id, Species)) #縦長に変換したい列を指定\ndf_long_tidy %>% head #並びが異なる\ndf_long_tidy %>% group_by(VarName) %>%  summarize(mean(Value))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n     id Species VarName      Value\n  <int> <fct>   <chr>        <dbl>\n1     1 setosa  Sepal.Length   5.1\n2     1 setosa  Sepal.Width    3.5\n3     1 setosa  Petal.Length   1.4\n4     1 setosa  Petal.Width    0.2\n5     2 setosa  Sepal.Length   4.9\n6     2 setosa  Sepal.Width    3  \n# A tibble: 4 × 2\n  VarName      `mean(Value)`\n  <chr>                <dbl>\n1 Petal.Length          3.76\n2 Petal.Width           1.20\n3 Sepal.Length          5.84\n4 Sepal.Width           3.06\n```\n\n\n:::\n:::\n\n\n\n\n`reshape`関数は多機能ゆえ、一度に2グループの列を集約することも可能ですが、 いっそう使用方法は複雑になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long2 <-reshape(df, direction = \"long\",\n        varying = c(\"Petal.Length\",\"Sepal.Length\",\"Petal.Width\",\"Sepal.Width\"), #縦長に変換したい列を指定\n        timevar = \"VarName\", #縦長に展開するときの、新たに追加されるキー列の名前\n        times = c(\"Length\",\"Width\"), #新たに追加されるキー列の中身(横長時の列名から指定)\n        v.names = c(\"Sepal\",\"Petal\")) #縦長になった結果集約される値が入る列の名前…2列以上も可\nhead(df_long2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         Species VarName Sepal Petal id\n1.Length  setosa  Length   5.1   1.4  1\n2.Length  setosa  Length   4.9   1.4  2\n3.Length  setosa  Length   4.7   1.3  3\n4.Length  setosa  Length   4.6   1.5  4\n5.Length  setosa  Length   5.0   1.4  5\n6.Length  setosa  Length   5.4   1.7  6\n```\n\n\n:::\n\n```{.r .cell-code}\n#実は同じような結果をもう少し簡単な指定で得ることもできる\ndf_long3 <-reshape(df, direction = \"long\",\n        varying = c(\"Petal.Length\",\"Sepal.Length\",\"Petal.Width\",\"Sepal.Width\"), #縦長に変換したい列を指定\n        timevar = \"VarName\", #縦長に展開するときの、新たに追加されるキー列の名前 \n        sep = \".\") #縦長に変換したい列が, 値が入る列の名前.新たに追加されるキー列の中身 という命名規則の場合\nhead(df_long3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         Species VarName Petal Sepal id\n1.Length  setosa  Length   1.4   5.1  1\n2.Length  setosa  Length   1.4   4.9  2\n3.Length  setosa  Length   1.3   4.7  3\n4.Length  setosa  Length   1.5   4.6  4\n5.Length  setosa  Length   1.4   5.0  5\n6.Length  setosa  Length   1.7   5.4  6\n```\n\n\n:::\n:::\n\n\n\n\n`data.table`の場合は次のような方法が考えられます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##data.tableのmeasure.varsにパターンを与える方法\ndt_long2 <- melt(dt, measure.vars = patterns(\"^Sepal\", \"^Petal\"),\n                 variable.name = \"Var\",\n                 value.name = c(\"Sepal\", \"Petal\"))\nhead(dt_long2)\n#1.15以降ではmeasure関数が追加された\n#https://rdatatable.gitlab.io/data.table/news/index.html#datatable-v1150-30-jan-2024\n#melt(dt, measure.vars = measure(value.name, dim, sep=\".\"))\n\n##添え字の中に欲しい形で書き下してしまう方法\ndt_long3 <- dt[,.(\n  VarName = c(rep(\"Length\", .N), rep(\"Width\", .N)),\n  Sepal = c(Sepal.Length, Sepal.Width),\n  Petal = c(Petal.Length, Petal.Width)\n) ,by = .(Species)]\nhead(dt_long3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Species    Var Sepal Petal\n    <fctr> <fctr> <num> <num>\n1:  setosa      1   5.1   1.4\n2:  setosa      1   4.9   1.4\n3:  setosa      1   4.7   1.3\n4:  setosa      1   4.6   1.5\n5:  setosa      1   5.0   1.4\n6:  setosa      1   5.4   1.7\n   Species VarName Sepal Petal\n    <fctr>  <char> <num> <num>\n1:  setosa  Length   5.1   1.4\n2:  setosa  Length   4.9   1.4\n3:  setosa  Length   4.7   1.3\n4:  setosa  Length   4.6   1.5\n5:  setosa  Length   5.0   1.4\n6:  setosa  Length   5.4   1.7\n```\n\n\n:::\n:::\n\n\n\n\n#### 縦長→横長\n\n逆に縦長から横長に戻す場合、R標準では次のような書き方になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_wide <- reshape(df_long, direction = \"wide\", #縦長への変換モード\n        varying = c(\"Sepal.Length\",\"Sepal.Width\",\"Petal.Length\",\"Petal.Width\"),#横長に展開するときの列名\n        timevar = \"VarName\", #横長に展開するときの列の基準が入った列\n        v.names = \"Value\") #横長に展開するときの値となる列\nhead(df_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               Species id Sepal.Length Sepal.Width Petal.Length Petal.Width\n1.Sepal.Length  setosa  1          5.1         3.5          1.4         0.2\n2.Sepal.Length  setosa  2          4.9         3.0          1.4         0.2\n3.Sepal.Length  setosa  3          4.7         3.2          1.3         0.2\n4.Sepal.Length  setosa  4          4.6         3.1          1.5         0.2\n5.Sepal.Length  setosa  5          5.0         3.6          1.4         0.2\n6.Sepal.Length  setosa  6          5.4         3.9          1.7         0.4\n```\n\n\n:::\n:::\n\n\n\n\n一方、`data.table`では`dcast`を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_long_tmp <- copy(dt_long)\ndt_long_tmp[ ,id := 1:.N, by = .(VarName)]\n#横長に戻した後の行番号を付与　これがないと集約されてしまう\n\ndt_wide <- dcast(dt_long_tmp,\n                 id + Species ~ VarName,\n                 #残したい列 ~ 横長に展開するときの列の名前が入った列\n                 value.var = \"Value\") #横長に展開するときの値となる列\n\nhead(dt_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <id, Species>\n      id Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n   <int>  <fctr>        <num>       <num>        <num>       <num>\n1:     1  setosa          5.1         3.5          1.4         0.2\n2:     2  setosa          4.9         3.0          1.4         0.2\n3:     3  setosa          4.7         3.2          1.3         0.2\n4:     4  setosa          4.6         3.1          1.5         0.2\n5:     5  setosa          5.0         3.6          1.4         0.2\n6:     6  setosa          5.4         3.9          1.7         0.4\n```\n\n\n:::\n:::\n\n\n\n\n`tidyr`では`pivot_wider`(または`spread`)を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_wide_tidy <- df_long_tidy %>%\n  pivot_wider(names_from = \"VarName\", #横長に展開するときの列の名前が入った列\n              values_from = \"Value\") #横長に展開するときの値となる列\ndf_wide_tidy %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n     id Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n  <int> <fct>          <dbl>       <dbl>        <dbl>       <dbl>\n1     1 setosa           5.1         3.5          1.4         0.2\n2     2 setosa           4.9         3            1.4         0.2\n3     3 setosa           4.7         3.2          1.3         0.2\n4     4 setosa           4.6         3.1          1.5         0.2\n5     5 setosa           5           3.6          1.4         0.2\n6     6 setosa           5.4         3.9          1.7         0.4\n```\n\n\n:::\n:::\n\n\n\n\nより複雑なパターンについてはvignette [\"Efficient reshaping using data.tables\"](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html)にも解説があります。\n\n### テーブルの結合(join)\n\nここでは複数のテーブルの結合を取り扱います。\n\n以下の例で使用するテーブルを準備します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ある時点での保有データ\n#システム仕様の都合により保険金額が2桁までしか保持できないため、\n#大型契約の場合は同じ証券番号で複数のレコードを保持して対応する\ndf_IF <- data.frame(\n  証券番号 = c(2, 2 ,3, 3, 99),\n  特約種類 = c(0, 0 ,0, 10, 0),\n  保有保険金額 = c(99, 30, 50, 25, 12)\n)\n#過去の消滅契約も含めた諸情報が蓄積されたデータ\n#ここでは、証券番号と特約種類の組によってレコードが特定されるものとする\n#ただし、df_IFに存在する証券番号99は特別なもので、当データベースには蓄積されていないものとする\ndf_MF <- data.frame(\n  証券番号 = c(1, 1 ,2, 3, 3),\n  特約種類 = c(0, 10, 0 ,0, 10),\n  契約年齢 = c(30, 30, 40, 50, 50),\n  性別 = c(1, 1, 2, 1, 1)\n)\n\ndt_IF <- as.data.table(df_IF)\ndt_MF <- as.data.table(df_MF)\n\ndf_IF\ndf_MF\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n  証券番号 特約種類 保有保険金額\n1        2        0           99\n2        2        0           30\n3        3        0           50\n4        3       10           25\n5       99        0           12\n  証券番号 特約種類 契約年齢 性別\n1        1        0       30    1\n2        1       10       30    1\n3        2        0       40    2\n4        3        0       50    1\n5        3       10       50    1\n```\n\n\n:::\n:::\n\n\n\n\nさて、保有テーブルに足りない情報を別のテーブルから付加するようなケースを考えます。\n\nR標準では`merge`という関数があります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#x側の行をすべて残す(left join)…MFにある情報をIFに付与する(契約年齢、性別がわかる)\nmerge(x = df_IF, y = df_MF,\n      by.x = c(\"証券番号\", \"特約種類\"), by.y = c(\"証券番号\", \"特約種類\"), #結合に使うキー\n      all.x = TRUE, all.y = FALSE) #どちらの行を残すか\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n  証券番号 特約種類 保有保険金額 契約年齢 性別\n1        2        0           99       40    2\n2        2        0           30       40    2\n3        3        0           50       50    1\n4        3       10           25       50    1\n5       99        0           12       NA   NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#両方にある行だけを抽出する(inner join)…MFに無いような変な契約は捨てる\nmerge(x = df_IF, y = df_MF,\n      by.x = c(\"証券番号\", \"特約種類\"), by.y = c(\"証券番号\", \"特約種類\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n  証券番号 特約種類 保有保険金額 契約年齢 性別\n1        2        0           99       40    2\n2        2        0           30       40    2\n3        3        0           50       50    1\n4        3       10           25       50    1\n```\n\n\n:::\n\n```{.r .cell-code}\n#y側の行をすべて残す(right join)…IFにある情報をMFに付与する(ある時点での保有の状況がわかる)\nmerge(x = df_IF, y = df_MF,\n      by.x = c(\"証券番号\", \"特約種類\"), by.y = c(\"証券番号\", \"特約種類\"),\n      all.x = FALSE, all.y = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n  証券番号 特約種類 保有保険金額 契約年齢 性別\n1        1        0           NA       30    1\n2        1       10           NA       30    1\n3        2        0           99       40    2\n4        2        0           30       40    2\n5        3        0           50       50    1\n6        3       10           25       50    1\n```\n\n\n:::\n:::\n\n\n\n\n`data.table`の場合、上記の手法も依然として使えますが、 `変数[行, 列]`記法の行の方に別の`data.table`を記述することでも実現できます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#dt_IFにあるレコードをキーとして、dt_MFのデータを取得する\n#onは結合に使うキーを指定　キーが異なるときはc(\"証券番号\" = \"証券番号\") のように指定する\ndt_MF[dt_IF, , on = .(証券番号, 特約種類)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   証券番号 特約種類 契約年齢  性別 保有保険金額\n      <num>    <num>    <num> <num>        <num>\n1:        2        0       40     2           99\n2:        2        0       40     2           30\n3:        3        0       50     1           50\n4:        3       10       50     1           25\n5:       99        0       NA    NA           12\n```\n\n\n:::\n\n```{.r .cell-code}\n#引数nomatch = NULLを与えることで両方にある行だけを抽出(inner join)\ndt_MF[dt_IF, , on = .(証券番号, 特約種類), nomatch = NULL]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   証券番号 特約種類 契約年齢  性別 保有保険金額\n      <num>    <num>    <num> <num>        <num>\n1:        2        0       40     2           99\n2:        2        0       40     2           30\n3:        3        0       50     1           50\n4:        3       10       50     1           25\n```\n\n\n:::\n\n```{.r .cell-code}\n#dt_MFにあるレコードをキーとして、dt_IFのデータを取得する\ndt_IF[dt_MF, , on = .(証券番号, 特約種類)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   証券番号 特約種類 保有保険金額 契約年齢  性別\n      <num>    <num>        <num>    <num> <num>\n1:        1        0           NA       30     1\n2:        1       10           NA       30     1\n3:        2        0           99       40     2\n4:        2        0           30       40     2\n5:        3        0           50       50     1\n6:        3       10           25       50     1\n```\n\n\n:::\n:::\n\n\n\n\n`dplyr`では`join`系の関数が使用できます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_IF %>% left_join(dt_MF, by = join_by(証券番号, 特約種類))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   証券番号 特約種類 保有保険金額 契約年齢  性別\n      <num>    <num>        <num>    <num> <num>\n1:        2        0           99       40     2\n2:        2        0           30       40     2\n3:        3        0           50       50     1\n4:        3       10           25       50     1\n5:       99        0           12       NA    NA\n```\n\n\n:::\n\n```{.r .cell-code}\ndt_IF %>% inner_join(dt_MF, by = join_by(証券番号, 特約種類))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   証券番号 特約種類 保有保険金額 契約年齢  性別\n      <num>    <num>        <num>    <num> <num>\n1:        2        0           99       40     2\n2:        2        0           30       40     2\n3:        3        0           50       50     1\n4:        3       10           25       50     1\n```\n\n\n:::\n\n```{.r .cell-code}\ndt_IF %>% right_join(dt_MF, by = join_by(証券番号, 特約種類))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   証券番号 特約種類 保有保険金額 契約年齢  性別\n      <num>    <num>        <num>    <num> <num>\n1:        2        0           99       40     2\n2:        2        0           30       40     2\n3:        3        0           50       50     1\n4:        3       10           25       50     1\n5:        1        0           NA       30     1\n6:        1       10           NA       30     1\n```\n\n\n:::\n:::\n\n\n\n\n### `data.table`が大規模データに強い理由\n\n`data.table`が大規模データに強い理由のうち、代表的なものを挙げると次のようになります。\n\n-   `fread`や`fwrite`は、標準の関数に比べて非常に高速\n-   `変数[行, 列]` の形式でデータ抽出・加工を行う場合、関係のないカラムをいちいち操作しない\n-   メモリの利用が効率的\n    -   `:=`による代入や`set*`系関数により、メモリのデータを丸ごとコピー(ディープコピー)することなくテーブルの加工を行うことが出来る\n-   いわゆるインデックスの機能がある\n    -   `dt[x == 10 & y == 20, ]` のようなクエリが発行されたとき、対応するインデックスが作成されていればそれを使用して高速にレコードを抽出できる。\n    -   `data.frame`から行idの機能が失われた代わりに、主キーとなる列(以下単に「キー列」)を複数持つことが出来る。キー列でソートされた形でテーブルを保持するため、キー列による検索は特に高速(いわゆるクラスター化インデックスに近い)\n    -   キー列とは別に、明示的にインデックスを作成することもできる(secondary index)\n    -   `dt[x == 10 & y == 20, ]` のようなクエリが発行された時点で、必要なインデックスを自動的に作成(auto indexing)\n-   マルチコア処理などの低レイヤの処理を最適化している\n\nこれらの特徴を把握することで、大規模データに強いコーディングを意図的に行うことも可能になります。\n\n大規模データでの動作を確認するために、いくつか例を見てみます。\n\n#### `fread`, `fwrite`の性能比較\n\nR標準の関数と簡単に速度比較をしてみます。\n\n環境・条件によっては、十数倍～数十倍程度の速度差が出ることもあるようです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nprint(file.info(\"../data/lapse_study.csv\")$size / 1024)#KB単位のファイルサイズ\n\nsystem.time(dt_tmp_r1 <- fread(\"../data/lapse_study.csv\"))\nsystem.time(dt_tmp_r2 <- read.csv(\"../data/lapse_study.csv\"))\nall(mapply(all.equal, dt_tmp_r1, dt_tmp_r2))\n```\n:::\n\n\n\n\n```         \n[1] 1949.819\n  ユーザ システム     経過 \n    0.00     0.00     0.02 \n  ユーザ システム     経過 \n    0.11     0.00     0.11 \n[1] TRUE\n```\n\n#### 大規模データ操作での性能比較\n\n公開データでは規模の大きい`nycflights13`パッケージの`flight`データを用いて、 `data.table`のデータ操作の速度を比較してみましょう。\n\nまず、簡単にデータの概要を表示します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_f <- flights\ndt_f <- as.data.table(df_f)\nnrow(df_f) #レコード数\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 336776\n```\n\n\n:::\n\n```{.r .cell-code}\nset.seed(42)\ndf_f[sample(nrow(df_f), 5), ] #サンプル抽出\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n1  2013    11     7      600            600         0      826            825\n2  2013    10    30     1252           1250         2     1356           1400\n3  2013    12    18     1723           1715         8     2008           2020\n4  2013    11    20     2029           2030        -1     2141           2205\n5  2013    10    21     1620           1625        -5     1818           1831\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(df_f) #サマリー\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      year          month             day           dep_time    sched_dep_time\n Min.   :2013   Min.   : 1.000   Min.   : 1.00   Min.   :   1   Min.   : 106  \n 1st Qu.:2013   1st Qu.: 4.000   1st Qu.: 8.00   1st Qu.: 907   1st Qu.: 906  \n Median :2013   Median : 7.000   Median :16.00   Median :1401   Median :1359  \n Mean   :2013   Mean   : 6.549   Mean   :15.71   Mean   :1349   Mean   :1344  \n 3rd Qu.:2013   3rd Qu.:10.000   3rd Qu.:23.00   3rd Qu.:1744   3rd Qu.:1729  \n Max.   :2013   Max.   :12.000   Max.   :31.00   Max.   :2400   Max.   :2359  \n                                                 NA's   :8255                 \n   dep_delay          arr_time    sched_arr_time   arr_delay       \n Min.   : -43.00   Min.   :   1   Min.   :   1   Min.   : -86.000  \n 1st Qu.:  -5.00   1st Qu.:1104   1st Qu.:1124   1st Qu.: -17.000  \n Median :  -2.00   Median :1535   Median :1556   Median :  -5.000  \n Mean   :  12.64   Mean   :1502   Mean   :1536   Mean   :   6.895  \n 3rd Qu.:  11.00   3rd Qu.:1940   3rd Qu.:1945   3rd Qu.:  14.000  \n Max.   :1301.00   Max.   :2400   Max.   :2359   Max.   :1272.000  \n NA's   :8255      NA's   :8713                  NA's   :9430      \n   carrier              flight       tailnum             origin         \n Length:336776      Min.   :   1   Length:336776      Length:336776     \n Class :character   1st Qu.: 553   Class :character   Class :character  \n Mode  :character   Median :1496   Mode  :character   Mode  :character  \n                    Mean   :1972                                        \n                    3rd Qu.:3465                                        \n                    Max.   :8500                                        \n                                                                        \n     dest              air_time        distance         hour      \n Length:336776      Min.   : 20.0   Min.   :  17   Min.   : 1.00  \n Class :character   1st Qu.: 82.0   1st Qu.: 502   1st Qu.: 9.00  \n Mode  :character   Median :129.0   Median : 872   Median :13.00  \n                    Mean   :150.7   Mean   :1040   Mean   :13.18  \n                    3rd Qu.:192.0   3rd Qu.:1389   3rd Qu.:17.00  \n                    Max.   :695.0   Max.   :4983   Max.   :23.00  \n                    NA's   :9430                                  \n     minute        time_hour                  \n Min.   : 0.00   Min.   :2013-01-01 05:00:00  \n 1st Qu.: 8.00   1st Qu.:2013-04-04 13:00:00  \n Median :29.00   Median :2013-07-03 10:00:00  \n Mean   :26.23   Mean   :2013-07-03 05:22:54  \n 3rd Qu.:44.00   3rd Qu.:2013-10-01 07:00:00  \n Max.   :59.00   Max.   :2013-12-31 23:00:00  \n                                              \n```\n\n\n:::\n:::\n\n\n\n\nカテゴリの数が多いカテゴリ変数で抽出する場合、`data.table`はインデックスの効果により抽出が高速になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigits_cur <- getOption(\"digits\")#表示桁数を一時的に少なくしておく\noptions(digits=3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#tailnumは機体記号(tail number) 航空機ごとにつけられる固有の記号のこと\n#本データセットには4000以上の機体記号が登録されている\nnrow(dt_f[,.N, by=.(tailnum) ])\n\n#microbenchmarkは同じ処理を複数回実行し、その実行時間を観察することができる関数\n#例えばmeanの列に平均実行時間がミリ秒単位で格納される\n\n#特定の機体記号のレコードを抽出するだけの処理\ndf_tmp <- microbenchmark(df_f[df_f$tailnum == \"N449US\", ], times=100, unit = \"milliseconds\") #R標準\ndf_tmp <- rbind(df_tmp, microbenchmark(dt_f[tailnum == \"N449US\", ], times=100, unit = \"milliseconds\")) #data.table:auto indexingによりインデックスを作成して使用するので早い\ndf_tmp <- rbind(df_tmp, microbenchmark(df_f %>% filter(tailnum == \"N449US\"), times=100, unit = \"milliseconds\")) #dplyr\ndf_tmp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4044\nUnit: milliseconds\n                                 expr  min   lq mean median   uq  max neval\n     df_f[df_f$tailnum == \"N449US\", ] 1.72 1.84 2.09   1.93 2.20 5.65   100\n          dt_f[tailnum == \"N449US\", ] 1.17 1.30 1.58   1.39 1.57 8.71   100\n df_f %>% filter(tailnum == \"N449US\") 2.93 3.00 3.58   3.18 3.59 7.40   100\n```\n\n\n:::\n:::\n\n\n\n\n多めの行を抽出しつつ限られた列に対してなんらかの演算を行う場合、`dplyr` が最も低速な傾向です。\n\n`変数[行, 列]`記法の場合、操作に関係のない列を自然に無視して処理できているためと考えられます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#R標準\n#行の抽出だけ\ndf_tmp <- microbenchmark(df_f[df_f$month == 12, ], times=100, unit = \"milliseconds\")\n#上記に加え、いくつかの列を使用して計算\n#文を2つに分けた都合上microbenchmarkの出力が2行に分かれるので、比較対象はその合計になる\nrows_tmp <- df_f$month == 12\ndf_tmp <- rbind(df_tmp, microbenchmark(rows_tmp <- df_f$month == 12, df_f[rows_tmp, \"hour\"]*60 + df_f[rows_tmp, \"minute\"], times=100, unit = \"milliseconds\"))\ndf_tmp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                                                   expr   min    lq  mean\n                               df_f[df_f$month == 12, ] 2.197 2.306 2.836\n                           rows_tmp <- df_f$month == 12 0.583 0.586 0.791\n df_f[rows_tmp, \"hour\"] * 60 + df_f[rows_tmp, \"minute\"] 0.913 0.950 1.048\n median    uq  max neval\n  2.442 2.985 6.39   100\n  0.595 0.884 5.60   100\n  0.966 1.010 5.72   100\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#data.table\ndf_tmp <- microbenchmark(dt_f[month == 12, ], times=100, unit = \"milliseconds\")\ndf_tmp <- rbind(df_tmp, microbenchmark(dt_f[month == 12, hour*60 + minute], times=100, unit = \"milliseconds\"))\ndf_tmp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                                  expr  min   lq mean median   uq  max neval\n                   dt_f[month == 12, ] 3.17 3.37 3.95   3.51 3.88 9.08   100\n dt_f[month == 12, hour * 60 + minute] 1.88 1.99 2.32   2.17 2.31 7.49   100\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#dplyr\ndf_tmp <- microbenchmark(df_f %>% filter(month == 12) , times=100, unit = \"milliseconds\")\ndf_tmp <- rbind(df_tmp, microbenchmark(df_f %>% filter(month == 12) %>% mutate(m = hour*60 + minute), times=100, unit = \"milliseconds\"))\n#mutate %>% select や transmute とするとさらに遅くなったのでそうしなかった\ndf_f_l <- df_f %>% select(month, hour, minute) #関係のない列をそぎ落としてもまだ若干低速\ndf_tmp <- rbind(df_tmp, microbenchmark(df_f_l %>% filter(month == 12) %>% mutate(m = hour*60 + minute), times=100, unit = \"milliseconds\"))\ndf_tmp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                                                              expr  min   lq\n                                      df_f %>% filter(month == 12) 3.41 3.55\n   df_f %>% filter(month == 12) %>% mutate(m = hour * 60 + minute) 4.31 4.47\n df_f_l %>% filter(month == 12) %>% mutate(m = hour * 60 + minute) 3.10 3.25\n mean median   uq    max neval\n 4.25   3.66 4.31   8.55   100\n 6.06   4.58 4.94 104.21   100\n 4.13   3.60 4.37   9.91   100\n```\n\n\n:::\n:::\n\n\n\n\nなお、キーやインデックスの詳細については以下のvignettesを参照してください。\n\n-   [Keys and fast binary search based subset](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-keys-fast-subset.html)\n-   [Secondary indices and auto indexing](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-keys-fast-subset.html)\n\nまた、本稿ではあまり説明していませんが、`set*`系関数などのメモリを節約する機能についてはvignette [\"Reference semantics\"](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reference-semantics.html)を参照してください。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(digits=digits_cur)#表示桁数を元に戻す\n```\n:::\n\n\n\n\n### 添え字の発展的な使用方法\n\n`data.table`は`dplyr`での操作にも対応しているため可読性の観点から併用されるケースが目立ちますが、 `data.table`の`変数[行, 列]`記法は`data.frame`のそれよりも大幅に拡張されており、 これをフルに活用することで複雑な処理をエレガントに記述することも可能です。 また前述のとおり、`変数[行, 列]`記法は大規模データでの実行速度向上の観点でもメリットがあります。 本節ではこの`変数[行, 列]`記法について少しだけ掘り下げてみます。\n\n#### 「列」の自在性\n\n「列」の箇所は、列名のみならず式を書くこともできます。 式中の列名をテーブルのカラム全体を表すベクトルに変換して計算するような動作になります。 結果の長さが元のベクトルとは異なっていても問題ないため、 `mean`のような集計関数(ベクトルを引数にとり数値を吐き出すような関数)も自然に使用できます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#.(*)はlist(*)の省略形で、listを与えたときはdata.tableで結果を返却する\nhead(dt[ ,.(Sepal.Length, Sepal.Width)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width\n          <num>       <num>\n1:          5.1         3.5\n2:          4.9         3.0\n3:          4.7         3.2\n4:          4.6         3.1\n5:          5.0         3.6\n6:          5.4         3.9\n```\n\n\n:::\n\n```{.r .cell-code}\n#.(*)のなかにx = aの形で記述することで、列名をxで返却する\nhead(dt[ ,.(SL = Sepal.Length)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      SL\n   <num>\n1:   5.1\n2:   4.9\n3:   4.7\n4:   4.6\n5:   5.0\n6:   5.4\n```\n\n\n:::\n\n```{.r .cell-code}\n#一方、右辺のほうには式を書くことができる\nhead(dt[ ,.(Sepal.Rate = Sepal.Length / Sepal.Width)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Rate\n        <num>\n1:   1.457143\n2:   1.633333\n3:   1.468750\n4:   1.483871\n5:   1.388889\n6:   1.384615\n```\n\n\n:::\n\n```{.r .cell-code}\n#ベクトルを引数にとり数値を吐き出すような関数も使える\ndt[ ,.(Sepal.Rate.Mean = mean(Sepal.Length / Sepal.Width))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Rate.Mean\n             <num>\n1:        1.953681\n```\n\n\n:::\n:::\n\n\n\n\n引数`by`を指定してグループ化した場合、上記の操作がグループごとに細分化されて行われるイメージです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[ ,.(Sepal.Rate.Mean = mean(Sepal.Length / Sepal.Width)), by = Species]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species Sepal.Rate.Mean\n       <fctr>           <num>\n1:     setosa        1.470188\n2: versicolor        2.160402\n3:  virginica        2.230453\n```\n\n\n:::\n:::\n\n\n\n\n#### 特殊記号(Special Symbols)\n\nまた、「列」の欄にはいくつかの特殊記号を用いることができます。\n\n代表的なものは、そのグループの件数を表す`.N`と、テーブル全体を表す`.SD`です。 このうち、`.SD`は引数`.SDcol`で抽出する列を指定することができます。\n\n`.SD`の応用例についてはvignette [\"Using .SD for Data Analysis\"](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-sd-usage.html)にも解説があります。 また、他の特殊記号の例については`help(\"special-symbols\")`を参照してください。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##.Nの使用例\ndt[ ,.(count = .N), by = Species]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species count\n       <fctr> <int>\n1:     setosa    50\n2: versicolor    50\n3:  virginica    50\n```\n\n\n:::\n\n```{.r .cell-code}\n##.SDの使用例\n#行数, 列名リスト, 全要素の合計値\nlist(nrow(dt), paste(names(dt), collapse = \",\"), sum(sapply(dt, function(vec) if(is.numeric(vec)){sum(vec)}else{0})))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 150\n\n[[2]]\n[1] \"Sepal.Length,Sepal.Width,Petal.Length,Petal.Width,Species\"\n\n[[3]]\n[1] 2078.7\n```\n\n\n:::\n\n```{.r .cell-code}\n#これをSpeciesのグループごとに行うイメージ\ndt[ ,.(nrow = nrow(.SD),\n       colnames = paste(names(.SD), collapse=\", \"),\n       sum = sum(sapply(.SD, function(vec) if(is.numeric(vec)){sum(vec)}else{0}))), by = Species]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species  nrow                                             colnames   sum\n       <fctr> <int>                                               <char> <num>\n1:     setosa    50 Sepal.Length, Sepal.Width, Petal.Length, Petal.Width 507.1\n2: versicolor    50 Sepal.Length, Sepal.Width, Petal.Length, Petal.Width 714.6\n3:  virginica    50 Sepal.Length, Sepal.Width, Petal.Length, Petal.Width 857.0\n```\n\n\n:::\n\n```{.r .cell-code}\n#.SDcolで指定した列だけを取り出し\ndt[ ,.(nrow = nrow(.SD),\n       colnames = paste(names(.SD), collapse=\", \"),\n       sum = sum(sapply(.SD, function(vec) if(is.numeric(vec)){sum(vec)}else{0}))), by = Species, .SDcol = c(\"Sepal.Length\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species  nrow     colnames   sum\n       <fctr> <int>       <char> <num>\n1:     setosa    50 Sepal.Length 250.3\n2: versicolor    50 Sepal.Length 296.8\n3:  virginica    50 Sepal.Length 329.4\n```\n\n\n:::\n:::\n\n\n\n\n#### 使用例：縦長への変形\n\nさて、ここまでに説明した内容を活用して、以下のテーブルを使いやすい形に成形してみましょう。\n\nこのテーブルは特約ごとに列が分かれてしまっており、主契約と特約を合算した数値を集計したりする場合にやや使いづらい構造になってしまっています。\n\nこれを「縦長」に変形することで使いやすくしてみます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_is\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   配当方式 商品種類コード  件数 特約1件数 特約2件数 主契約保険金額\n     <char>          <int> <num>     <num>     <num>          <num>\n1:     有配              1    10        10         0            100\n2:     有配              2    16         0         0             60\n3:   準有配              3    48        24         0            240\n4:     無配              4   176       110         0             69\n5:     無配              5   190        30        14           1931\n6:     無配              6    15        12         0            300\n   特約1保険金額 特約2保険金額\n           <num>         <num>\n1:           100             0\n2:             0             0\n3:            24             0\n4:            59             0\n5:          3140           156\n6:           240             0\n```\n\n\n:::\n:::\n\n\n\n\n「縦長」に変形するには、例えば件数、特約1件数、特約2件数を「縦」に並べる必要があります。\n\nすなわち以下のような操作をすることになります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(dt_is$件数, dt_is$特約1件数, dt_is$特約2件数)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n [1]  10  16  48 176 190  15  10   0  24 110  30  12   0   0   0   0  14   0\n```\n\n\n:::\n:::\n\n\n\n\nこのベクトルを「件数」という列に格納して返却する式はこのようになります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_is[, .(件数 = c(件数, 特約1件数, 特約2件数))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     件数\n    <num>\n 1:    10\n 2:    16\n 3:    48\n 4:   176\n 5:   190\n 6:    15\n 7:    10\n 8:     0\n 9:    24\n10:   110\n11:    30\n12:    12\n13:     0\n14:     0\n15:     0\n16:     0\n17:    14\n18:     0\n```\n\n\n:::\n:::\n\n\n\n\n主契約や特約を区別できるように、新たに特約種類なる列を追加します。\n\nもとのレコードの数と同じ長さのベクトルを3本用意する必要がありますが、ここで特殊記号`.N`が活躍します。\n\nついでに保険金額の列も追加しておきます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_is[, .(特約種類 = c(rep(0, .N), rep(1, .N), rep(2, .N)), \n          件数 = c(件数, 特約1件数, 特約2件数),\n          保険金額 = c(主契約保険金額, 特約1保険金額, 特約2保険金額))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n    特約種類  件数 保険金額\n       <num> <num>    <num>\n 1:        0    10      100\n 2:        0    16       60\n 3:        0    48      240\n 4:        0   176       69\n 5:        0   190     1931\n 6:        0    15      300\n 7:        1    10      100\n 8:        1     0        0\n 9:        1    24       24\n10:        1   110       59\n11:        1    30     3140\n12:        1    12      240\n13:        2     0        0\n14:        2     0        0\n15:        2     0        0\n16:        2     0        0\n17:        2    14      156\n18:        2     0        0\n```\n\n\n:::\n:::\n\n\n\n\nグループ化の単位となる引数`by`にキー列を指定することで、これらを自然に補完することができます。\n\nこれで欲しい形式にテーブルを変換することができました。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_is[, .(特約種類 = c(rep(0, .N), rep(1, .N), rep(2, .N)), \n          件数 = c(件数, 特約1件数, 特約2件数),\n          保険金額 = c(主契約保険金額, 特約1保険金額, 特約2保険金額)),\n      by = .(配当方式, 商品種類コード)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n    配当方式 商品種類コード 特約種類  件数 保険金額\n      <char>          <int>    <num> <num>    <num>\n 1:     有配              1        0    10      100\n 2:     有配              1        1    10      100\n 3:     有配              1        2     0        0\n 4:     有配              2        0    16       60\n 5:     有配              2        1     0        0\n 6:     有配              2        2     0        0\n 7:   準有配              3        0    48      240\n 8:   準有配              3        1    24       24\n 9:   準有配              3        2     0        0\n10:     無配              4        0   176       69\n11:     無配              4        1   110       59\n12:     無配              4        2     0        0\n13:     無配              5        0   190     1931\n14:     無配              5        1    30     3140\n15:     無配              5        2    14      156\n16:     無配              6        0    15      300\n17:     無配              6        1    12      240\n18:     無配              6        2     0        0\n```\n\n\n:::\n:::\n\n\n\n\nちなみに、`[,]`は複数回つなげて記述することができます。 例えば主契約・特約を合算しつつ配当方式別に集計したテーブルはこのように作れます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_is[, .(特約種類 = c(rep(0, .N), rep(1, .N), rep(2, .N)), \n          件数 = c(件数, 特約1件数, 特約2件数),\n          保険金額 = c(主契約保険金額, 特約1保険金額, 特約2保険金額)),\n      by = .(配当方式, 商品種類コード)][\n        ,.(件数合計 = sum(件数), 保険金額合計 = sum(保険金額)), by = .(配当方式)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` output-jp\n   配当方式 件数合計 保険金額合計\n     <char>    <num>        <num>\n1:     有配       36          260\n2:   準有配       72          264\n3:     無配      547         5895\n```\n\n\n:::\n:::\n\n\n\n\nなお、`変数[行, 列]` 記法はSQL文との関連で次のように対応付けられることがあります。\n\n```         \nSELECT aaa\nFROM bbb\nWHERE ccc\nGROUP BY ddd\nORDER BY eee\n↓\nbbb[ccc/eee, aaa, by = ddd]\n※uPDATE文の場合は .(xxx := aaa) の形\n```\n\n今回の例からも、`変数[行, 列]` 記法は単なる添え字にとどまらず、SQLクエリと同等あるいはそれ以上の自在性を持つことがわかります。\n\nこのような`data.table`独特の哲学については以下のvignettesにも解説があります。\n\n-   [Introduction to data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)\n-   [Frequently Asked Questions about data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-faq.html)\n\n### NSEの問題\n\n#### `..`について\n\n前述のとおり`変数[行, 列]`記法は自在性が高い一方、その自在性を実現するために添え字の処理が通常とは異なっており、 例えば以下のように列名を変数に格納して列を抽出するようなコードがエラーとなってしまいます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolname <- \"Sepal.Length\"\nhead(df[, colname]) #OK\nhead(dt[, colname]) #ERROR\n#Error in `[.data.table`(dt, , colname) :\n#j (the 2nd argument inside [...]) is a single symbol but column name 'colname' is not found. Perhaps you intended DT[, #..colname]. This difference to data.frame is deliberate and explained in FAQ 1.1.\n```\n:::\n\n\n\n\nこれは「列」部分のシンボルが1つであると処理が特殊なためで、エラー文のとおり`..colname`とすれば解決できます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolname <- \"Sepal.Length\"\nhead(dt[, ..colname])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length\n          <num>\n1:          5.1\n2:          4.9\n3:          4.7\n4:          4.6\n5:          5.0\n6:          5.4\n```\n\n\n:::\n:::\n\n\n\n\nシンボルが2個以上であればいいのでは？とばかりに`colname`の後ろに空文字列を連結するという意味のない処理を加えると…\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dt[, paste0(colname, \"\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Sepal.Length\"\n```\n\n\n:::\n:::\n\n\n\n\nSQLでいえば`SELECT 'Sepal.Length'`を実行したかのような結果になってしまいます。\n\n`dt[, \"Sepal.Length\"]`では期待通り`Sepal.Length`の列を抽出できていたわけですが、 これは文字列だけが「列」の箇所に記述されたときの特殊仕様。 前述の添え字の動作原理を把握しているならば、むしろ上記の実行結果のほうが整合的です。\n\nともかく、添え字の自在性と引き換えに、 列名などを文字列で与えて処理を行うには工夫が必要になってしまっているということです。\n\n#### `[[ ]]`の利用\n\nより複雑な例として、以下のように既存の特徴量を2乗した特徴量を追加する操作について、 これを他の特徴量でも簡単に使いまわせるように関数化することを考えます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_tmp <- copy(dt)\ndt_tmp[,Sepal.Length_Squared := Sepal.Length ^ 2][,Sepal.Width_Squared := Sepal.Width ^ 2]\nhead(dt_tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <num>       <num>        <num>       <num>  <fctr>\n1:          5.1         3.5          1.4         0.2  setosa\n2:          4.9         3.0          1.4         0.2  setosa\n3:          4.7         3.2          1.3         0.2  setosa\n4:          4.6         3.1          1.5         0.2  setosa\n5:          5.0         3.6          1.4         0.2  setosa\n6:          5.4         3.9          1.7         0.4  setosa\n   Sepal.Length_Squared Sepal.Width_Squared\n                  <num>               <num>\n1:                26.01               12.25\n2:                24.01                9.00\n3:                22.09               10.24\n4:                21.16                9.61\n5:                25.00               12.96\n6:                29.16               15.21\n```\n\n\n:::\n\n```{.r .cell-code}\ndt_tmp[, .(sum(Sepal.Length_Squared), sum(Sepal.Width_Squared)), by = Species] #後で実行結果を検証するためのもの\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species      V1     V2\n       <fctr>   <num>  <num>\n1:     setosa 1259.09 594.60\n2: versicolor 1774.86 388.47\n3:  virginica 2189.90 447.33\n```\n\n\n:::\n:::\n\n\n\n\nこの操作を、例えば `add_square(dt_tmp, c(\"Sepal.Length\",\"Sepal.Width\"))` のように呼び出せるようにしたいとしましょう。\n\nこれをシンプルに変数に置き換えた以下の形では残念ながらエラーとなってしまいます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_square <- function(dt_tmp, cols){\n  for(col in cols)\n    dt_tmp[,paste0(col, \"_Squared\") := col ^ 2]\n}\ndt_tmp <- copy(dt)\nadd_square(dt_tmp, c(\"Sepal.Length\",\"Sepal.Width\"))#ERROR\n#Error in col^2 : non-numeric argument to binary operator\n```\n:::\n\n\n\n\n一番シンプルな解決策は`[[ ]]`を用いることです。`:=`を使用することにこだわらないのであれば`<-`による代入でもよいでしょう。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_square <- function(dt_tmp, cols){\n  for(col in cols)\n    dt_tmp[, paste0(col, \"_Squared\") := dt_tmp[[col]]^2 ] # := の左辺は文字列でもOK\n}\ndt_tmp <- copy(dt)\nadd_square(dt_tmp, c(\"Sepal.Length\",\"Sepal.Width\"))\ndt_tmp[, .(sum(Sepal.Length_Squared), sum(Sepal.Width_Squared)), by = Species]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species      V1     V2\n       <fctr>   <num>  <num>\n1:     setosa 1259.09 594.60\n2: versicolor 1774.86 388.47\n3:  virginica 2189.90 447.33\n```\n\n\n:::\n:::\n\n\n\n\n#### `.SD`の利用\n\n`data.table`特有の記法を用いた解決策もあります。 `.SD`は引数`.SDcol`で取り出す列を指定することができることを利用します。 簡潔な記述で複数列一度に処理できるためおすすめです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_square <- function(dt_tmp, cols){\n  dt_tmp[, paste0(cols, \"_Squared\") := (.SD ^ 2), .SDcol = cols]\n}\ndt_tmp <- copy(dt)\nadd_square(dt_tmp, c(\"Sepal.Length\",\"Sepal.Width\"))\ndt_tmp[, .(sum(Sepal.Length_Squared), sum(Sepal.Width_Squared)), by = Species]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species      V1     V2\n       <fctr>   <num>  <num>\n1:     setosa 1259.09 594.60\n2: versicolor 1774.86 388.47\n3:  virginica 2189.90 447.33\n```\n\n\n:::\n:::\n\n\n\n\nこのような例については以下のvignetteにも解説があります。\n\n-   [Programming on data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-programming.html)\n\n#### `substitute`の利用\n\nこの`変数[行,列]`記法のように、通常の評価とは異なる評価が行われることをNSE(Non Standard Evaluation)といい、R言語でしばしば現れる概念です。\n\nR言語には遅延評価(lazy evaluation)という概念があり、 スクリプトに書かれた式はその値が必要になるタイミングまで評価(≒計算)されません。\n\nたとえば関数の引数に式が書かれた場合、関数の処理に入る前に評価するのではなく、 関数の処理の中で必要となったタイミングで評価を行いますが、 NSEとはこの評価方法が特殊なもののことをいいます。 身近な例では`lm`などの引数に現れる`y ~ .`の形の式や、`dplyr`の記法などがあります。\n\n`data.table`以外にもNSEが行われる場合はしばしば上記のような問題を抱えるため、 他のケースでも用いられる解決策も参考までに提示します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_square <- function(dt_tmp, cols){\n  for(col in cols){\n    eval(substitute(\n      dt_tmp[, var_col_Squared := var_col ^ 2],\n      env = list(var_col = as.name(col), var_col_Squared = paste0(col, \"_Squared\"))\n    ))\n    #バージョン1.15以降では上記機能が[.data.tableの引数`env`に組み込まれました。\n    #https://rdatatable.gitlab.io/data.table/news/index.html#datatable-v1150-30-jan-2024\n  }\n}\ndt_tmp <- copy(dt)\nadd_square(dt_tmp, c(\"Sepal.Length\",\"Sepal.Width\"))\ndt_tmp[, .(sum(Sepal.Length_Squared), sum(Sepal.Width_Squared)), by = Species]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species      V1     V2\n       <fctr>   <num>  <num>\n1:     setosa 1259.09 594.60\n2: versicolor 1774.86 388.47\n3:  virginica 2189.90 447.33\n```\n\n\n:::\n:::\n\n\n\n\n#### `rlang`パッケージの利用\n\nこのような状況では`rlang`パッケージが使用されることも多いため、一例を示します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_square <- function(dt_tmp, cols){\n  for(col in cols){\n    col_sym <- rlang::sym(col) #文字列をシンボルに変換\n    rlang::inject(dt_tmp[, paste0(col, \"_Squared\") := (!!col_sym) ^ 2])\n    #rlang::injectで囲むと、!!col_symの部分がSepal.Lengthなどのシンボルに置換される\n  }\n}\ndt_tmp <- copy(dt)\nadd_square(dt_tmp, c(\"Sepal.Length\",\"Sepal.Width\"))\ndt_tmp[, .(sum(Sepal.Length_Squared), sum(Sepal.Width_Squared)), by = Species]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Species      V1     V2\n       <fctr>   <num>  <num>\n1:     setosa 1259.09 594.60\n2: versicolor 1774.86 388.47\n3:  virginica 2189.90 447.33\n```\n\n\n:::\n:::\n",
    "supporting": [
      "datatable_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
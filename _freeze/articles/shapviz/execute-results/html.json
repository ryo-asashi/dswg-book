{
  "hash": "fb8c0dbad6a194a0350cbc7145b0c457",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"shapviz\"\nauthor: \"データサイエンス関連基礎調査WG\"\ndate: \"2025-08-01\"\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    fig-width: 6\n    fig-height: 5\n    df-print: \"paged\"\nreferences:\n- id: BIB_AER_HEALTHINSURANCE\n  type: article\n  title: \"R: Medical Expenditure Panel Survey Data\"\n  URL: https://search.r-project.org/CRAN/refmans/AER/html/HealthInsurance.html\n  author:\n    - Achim Zeileis\n  issued:\n    - year: 2024\n  accessed:\n    - year: 2024\n      month: 8\n      day: 6\n- id: BIB_SHAPVIZ_VIGNETTES_BASIC\n  type: article\n  title: \"Using ‘shapviz’\"\n  URL: https://cran.r-project.org/web/packages/shapviz/vignettes/basic_use.html\n  author:\n    - Michael Mayer\n    - Adrian Stando \n  issued:\n    - year: 2024\n  accessed:\n    - year: 2024\n      month: 8\n      day: 10\n- id: BIB_SHAPVIZ_VIGNETTES_GEOGRAPHIC\n  type: article\n  title: \"Geographic Components\"\n  URL: https://cran.r-project.org/web/packages/shapviz/vignettes/geographic.html\n  author:\n    - Michael Mayer\n    - Adrian Stando \n  issued:\n    - year: 2024\n  accessed:\n    - year: 2024\n      month: 8\n      day: 10\n- id: BIB_SHAPVIZ_VIGNETTES_MULTIPLE\n  type: article\n  title: \"Multiple ‘shapviz’ objects\"\n  URL: https://cran.r-project.org/web/packages/shapviz/vignettes/multiple_output.html\n  author:\n    - Michael Mayer\n    - Adrian Stando \n  issued:\n    - year: 2024\n  accessed:\n    - year: 2024\n      month: 8\n      day: 10\n- id: BIB_GGPLOT2_VIRIDIS\n  type: article\n  title: \"Viridis colour scales from viridisLite — scale_colour_viridis_d • ggplot2\"\n  URL: https://ggplot2.tidyverse.org/reference/scale_viridis.html\n  author:\n    - H. Wickham\n  issued:\n    - year: 2024\n  accessed:\n    - year: 2024\n      month: 8\n      day: 10\n- id: BIB_VIRIDIS_INTRO\n  type: article\n  title: \"Introduction to the viridis color maps • viridis\"\n  URL: https://sjmgarnier.github.io/viridis/articles/intro-to-viridis.html\n  author:\n    - Bob Rudis\n    - Noam Ross\n    - Simon Garnier\n  issued:\n    - year: 2024\n  accessed:\n    - year: 2024\n      month: 8\n      day: 10\n- id: BIB_BOOK_AER\n  type: book\n  publisher: Springer\n  title: Applied Econometrics with R\n  author:\n    - Christian Kleiber\n    - Achim Zeileis\n  issued:\n    date-parts:\n    - - 2008\n      - 8\n      - 28\n- id: BIB_JOURNAL_IAJ_IML\n  type: article-journal\n  container-title: アクチュアリージャーナル\n  publisher: 日本アクチュアリー会\n  volume: '127'\n  page: 78-117\n  title: Interpretable Machine Learning\n  author:\n    - データサイエンス関連基礎調査WG　大江麗地\n  issued:\n    - year: 2024\n      month: 6\n- id: BIB_MEPS\n  type: article\n  title: \"Medical Expenditure Panel Survey (MEPS) | Agency for Healthcare Research and Quality\"\n  URL: https://www.ahrq.gov/data/meps.html\n  author:\n    - Agency for Healthcare Research and Quality\nnocite: |\n  @*\n---\n\n\n\n\n\n\n## パッケージの概要\n\nshapvizは、予測モデルの解釈手法の一種であるSHAPの可視化に特化したパッケージです。\ntreeshapやkernelshap等のSHAPを計算するパッケージと組み合わせて使用します。\n\n### SHAPとは\n\nSHAPという手法については @BIB_JOURNAL_IAJ_IML に解説があるため、こちらを参照することをお勧めします。\n以下では詳細な説明は避け、概要のみを記載します。\n\n**SHAP(SHapley Additive exPlanation)**とは予測モデルの解釈に用いられる手法の一種で、\nある予測モデルの入力（説明変数）と出力（予測値）の組に対して、\n**どの説明変数の寄与によってその予測値となったのかを加法的に分解**するものです。\n\n$$ 個別の予測値 = その予測の説明変数1の寄与 + \\cdots + その予測の説明変数Nの寄与 + 予測値平均$$\n\nこのようにして分解された各サンプル・説明変数の寄与を**SHAP値**と呼びます。\n\n個別サンプルの予測に対する解釈を与える、いわゆるローカルな手法だと考えられますが、\n多くのサンプルのSHAPを計算してそれをグラフにする、平均値で要約する等により、\nモデル全体の解釈を与える、いわゆるグローバルな手法としても使用することが出来ます。\n\n## 準備\n\n### パッケージの読み込み\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(AER) #データセット\n\nlibrary(tibble) #data.frame拡張版\nlibrary(dplyr) #data.frameの操作\nlibrary(rsample) #データ分割\nlibrary(recipes) #前処理\n\nlibrary(xgboost) #今回使用するモデルのパッケージ\nlibrary(ROCR) #精度評価\nlibrary(treeshap) #SHAPの計算\n\nlibrary(ggplot2) #グラフの描画\nlibrary(patchwork) #複数のgpplotを組み合わせる\nlibrary(shapviz) #SHAPの可視化\n```\n:::\n\n\n\n\n\n### データセットの読み込み\n\n@BIB_BOOK_AER で使用されたデータセット等をまとめたパッケージAERに含まれる、\nHealthInsuranceというデータセットを使用します。\n\n性別・年齢・学歴・家族構成・雇用状態（自営業か否か）健康保険の加入状況等に関する\n約9,000個のサンプルが含まれています。\n今回は、健康保険に加入しているかどうかを予測するモデルを作成することとします。\n\nデータセットの詳細については @BIB_AER_HEALTHINSURANCE を参照してください[^dataset]。\n\n[^dataset]: 元の研究は、自営業者の健康保険加入率の低さと健康状態の関係性を調べたものです。この研究で用いられた、1996年の米国医療費パネル調査(MEPS[@BIB_MEPS])から抽出されたものがこのデータセットです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"HealthInsurance\")\ndf_all <- HealthInsurance\n\nsummary(df_all)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n health          age        limit         gender     insurance  married   \n no : 629   Min.   :18.00   no :7571   female:4169   no :1750   no :3369  \n yes:8173   1st Qu.:30.00   yes:1231   male  :4633   yes:7052   yes:5433  \n            Median :39.00                                                 \n            Mean   :38.94                                                 \n            3rd Qu.:48.00                                                 \n            Max.   :62.00                                                 \n                                                                          \n selfemp        family             region     ethnicity         education   \n no :7731   Min.   : 1.000   northeast:1682   other: 365   none      :1119  \n yes:1071   1st Qu.: 2.000   midwest  :2023   afam :1083   ged       : 374  \n            Median : 3.000   south    :3075   cauc :7354   highschool:4434  \n            Mean   : 3.094   west     :2022                bachelor  :1549  \n            3rd Qu.: 4.000                                 master    : 524  \n            Max.   :14.000                                 phd       : 135  \n                                                           other     : 667  \n```\n\n\n:::\n:::\n\n\n\n\n### 前処理\n\n今回例として使用するモデルでは、説明変数が数値型である必要があるので、factor型変数を数値型に変換しておきます[^prep]。\n\n[^prep]:なお、ここではデータ前処理にrecipesパッケージを使用しています。\n        また、`%>%`はmagrittrパッケージによるパイプ演算子で、右辺の関数の第1引数に左辺を渡すという働きがあります。\n        たとえば`a %>% f %>% g(b)`という記述は`g(f(a),b)`と同等です。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_init <- df_all %>% recipe(insurance ~ .) %>% #前処理手順の定義\n  #ethinicityは最も多いカテゴリがcaucなので、これを基準カテゴリに変更\n  step_relevel(ethnicity, ref_level = \"cauc\") %>% \n  #educationは学歴を表す説明変数で、大きいほど高学歴であるため、そのままダミー変数にするのではなく、数値に変換\n  step_mutate(education_main = as.numeric(education) - 1) %>%\n  #ただし、最後のカテゴリだけは「その他」を表しているので、これだけは別のダミー変数に分離する\n  step_mutate(education_other = if_else(education_main == 6, 1, 0)) %>%\n  step_mutate(education_main = if_else(education_main < 6, education_main, 0)) %>%\n  step_rm(education) %>%\n  step_dummy(all_factor_predictors()) %>% #他のfactor型変数は単純にダミー変数化\n  step_relevel(insurance, ref_level = \"yes\")\n  #目的変数は健康保険に加入しているかを表すinsurance\n\ndf_baked <- rec_init %>% prep() %>% bake(new_data = NULL) #上記で定義した前処理手順を実際に実行\n```\n:::\n\n\n\n\n上記前処理を施したうえで、学習データとテストデータに分割します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\nsplit_df <- rsample::initial_split(df_baked, prop = 0.8) #80%を学習データ、20%をテストデータとする\ndf_train <- rsample::training(split_df)\ndf_test <- rsample::testing(split_df)\n\ndf_train_x <- df_train %>% dplyr::select(-insurance)\ndf_train_y <- df_train$insurance\ndf_test_x <- df_test %>% dplyr::select(-insurance)\ndf_test_y <- df_test$insurance\n```\n:::\n\n\n\n\n### モデル構築\n\n続いてXGBoostによる予測モデルを学習データをもとに構築します。[^omittune]\n\n2値分類の問題ですが、予測モデルの出力としては加入しているか否かの2通りではなく、\n加入している確率を出力するようにしています。\n\n[^omittune]:ハイパーパラメータは事前にチューニングしたものを入力しています。\n            チューニングの過程については本稿の主題を外れるので、割愛します。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\nmodel_xgboost <- xgboost(data = as.matrix(df_train_x), label = as.matrix(2 - as.numeric(df_train_y)), nrounds = 100,\n                  params = list(eta = 0.3, max_depth = 2, gamma = 0, min_child_weight = 1, \n                             subsample = 1, colsample_bytree = 1, colsample_bynode = 2/14, objective = \"binary:logistic\"),\n                  verbose = 0)\n```\n:::\n\n\n\n\n\n構築した予測モデルの精度をテストデータを用いて確認しておきます。\n\nここではAUC(ROC)を確認します。これは2値分類モデルで使用される評価指標で、高いほど精度が良いという評価になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_score <- function(object, predfun, df_test_x, df_test_y){\n  yhat <- object %>% predfun(df_test_x)\n  pr <- ROCR::prediction(yhat, df_test_y)\n  auc <- pr %>% ROCR::performance(\"auc\")\n  auc_plot <- pr %>% ROCR::performance(\"tpr\", \"fpr\")\n  list(\n    auc_plot = auc_plot,\n    auc = auc@y.values %>% as.numeric()\n    )\n}\n\npredfun_xgboost <- function(object, newdata){\n  dt <- as.matrix(newdata)\n  object %>% predict(newdata = dt)\n}\nscore <- calc_score(model_xgboost, predfun_xgboost, df_test_x, df_test_y)\nscore$auc_plot %>% plot()\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/xgb_test-1.png){width=576}\n:::\n\n```{.r .cell-code}\nscore$auc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7503933\n```\n\n\n:::\n:::\n\n\n\n\n0.75は高くもなく低くもないといった程度ではあるものの、用途によってはこれでも十分でしょう。\n（例えば True Positive Rate = 0.6, False Positive Rate = 0.2 あたりとなるしきい値をとれば、\n　全体の8割程度を占める加入者のうち6割を削減しつつ、少数派の非加入者のうち8割を残した集団が作れる）\n　\n\n\n## 基本的な使用方法\n\nまずは別のパッケージを用いてSHAPを計算します。\nここでは計算が高速なtreeshapを使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024) #SHAPを計算したいサンプル\nnrow_shap <- nrow(df_train) #SHAPは計算コストが高いことが多いが、treeshapであれば全サンプルでも問題ない\ndf_shap <- df_train[sample(nrow(df_train), nrow_shap), ]\ndf_shap_x <- df_shap %>% dplyr::select(-insurance)\n\nt1 <- proc.time()\n\nobj_uni <- treeshap::unify(model_xgboost, df_shap_x)\nshap_ts <- treeshap::treeshap(obj_uni, x = df_shap_x)\n\nt2 <- proc.time()\nt0 <- (t2-t1)[3]\nnames(t0) <- NULL\n\ncat(\"処理時間:\", t0, \"秒\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n処理時間: 0.44 秒\n```\n\n\n:::\n:::\n\n\n\n\n次に、`shapviz`関数でshapvizパッケージで可視化できるオブジェクトに変換します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsv <- shapviz::shapviz(shap_ts)\n```\n:::\n\n\n\n\n\n最後に、このオブジェクトをshapvizパッケージの関数に入力することで可視化できます。\n例えば、個別のサンプルに対する寄与の分解を表示するには次のようにします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_waterfall(sv, row_id = 1) #1つ目のサンプルの予測結果に対してプロット\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/basic_waterfall-1.png){width=576}\n:::\n:::\n\n\n\n\nこのサンプルでは、自営業であること（`selfemp_yes=1`）や独身である（`married_yes=0`）ことによって、\n平均的な被験者よりも健康保険に加入しない傾向にあると判断されたようです。\n\n上記`sv_waterfall`の他にも可視化を行う関数が色々用意されていますが、基本的な使用方法は同様です。\n\n## 可視化方法一覧\n\n### SHAP Summary Plot\n\nグローバルな手法として全サンプルの結果を一覧に表示し、\n説明変数ごとに全般的にどの程度寄与しているかをプロットするには次のようにします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_importance(sv, kind = \"beeswarm\")\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/sv_summary-1.png){width=576}\n:::\n:::\n\n\n\n\n横軸は寄与の大きさを、色付けは説明変数の値を示しており、\n例えば明るい色の点が右側にある場合は、その説明変数が高いほど予測確率が高くなることを示します。\n\nデフォルトでは寄与が大きい説明変数から順に並べられるので、\n最も予測確率への寄与が大きい説明変数は学歴（`education_main`）であることがわかります。\nまた、学歴が高いほど健康保険に加入する傾向があることがわかります。\n\n\n### SHAP Feature Importance Plot\n\nSummary Plotは各サンプルの寄与をすべてプロットしていました。\n\n寄与の絶対値の大きいサンプルが多い説明変数は重要であると考えられるので、\nその平均値を棒グラフにして描画することで、どれが重要な説明変数なのかが一目でわかるようになります。\n\nこのようなプロットをFeature Importance Plot（特徴量重要度プロット）といい、プロットするには次のようにします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_importance(sv)\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/sv_importance-1.png){width=576}\n:::\n:::\n\n\n\n\n### SHAP Dependence Plot\n\nここまでは説明変数の寄与の大きさを比較することを主目的としていました。\n各説明変数に着目して、それがどのように寄与しているかはSummary Plotでも確認可能ですが、\n横軸に説明変数の値、縦軸に寄与としたグラフをプロットすることも考えられます。\n\nこれをDependence Plotといい、プロットするには`sv_dependence`関数を使用します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_dependence(sv, v = c(\"education_main\", \"age\"), color_var = NULL)\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/sv_dependence_null-1.png){width=768}\n:::\n:::\n\n\n\n\n学歴がおおむね線形に影響を及ぼすことはSummary Plotでも大まかには確認できましたが、このようなグラフにすることでより明確になりました。\nまた、年齢が与える影響は非常に複雑で、20代前半で一度加入率が落ち込み、以降は少しずつ上がっていくという推移になることがわかります。\n\nこのプロットでは横軸が同じでも、縦軸（寄与）が異なる点が多数描かれています。\nこれはサンプルによって寄与が異なるためで、交互作用がある場合にこのような現象が発生します。\n\n引数`color_var`を省略するか`\"auto\"`とすることで、交互作用の大きい説明変数を自動で選び、その値によってグラフが色分けされるようになります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_dependence(sv, v = c(\"education_main\", \"age\"), color_var = \"auto\")\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/sv_dependence_auto-1.png){width=768}\n:::\n:::\n\n\n\n\n- 学歴（`education_main`）と交互作用のある説明変数としては婚姻状況（`married_yes`）が選ばれました。\n  高卒・大卒（`education_main`が1～3）では結婚している場合は若干SHAP値が上がる一方、それ以外の場合はその逆となるようです。\n  ややこしい話ですが、婚姻状況（`married_yes`）のSHAP値が、結婚している場合に正であるという状況はどのサンプルでも変わらないので、\n  結婚による加入率上昇はどの学歴層でもみられるものの、その効果は学歴によって差があるということになります。\n- 年齢（`age`）と交互作用のある説明変数としては、居住地域が西側であるかどうか（`region_west`）が選ばれました。\n  全体的な形はあまり変わらないように思われますが、居住地域が西側の場合、30歳前後での加入率が下がるようです。\n\n\n引数`color_var`に説明変数名を指定することで、好きな特徴量で色分けをすることができます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_dependence(sv, v = \"age\", color_var = \"married_yes\")\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/sv_dependence_specified-1.png){width=576}\n:::\n:::\n\n\n\n\n20代前半では結婚している（`married_yes=1`）と健康保険への加入率が低いように見える一方、それより上の年代では大きく差はないように見えます。\n\n### 2D SHAP Dependence Plot\n\n前述のSHAP Dependence Plotでは2つの説明変数の関係を色分けで示していましたが、\n別の方法として縦軸と横軸に説明変数をとる方法もあります。使用する関数は`sv_dependence2D`関数です。\nここで**色分けに使用されるSHAP値は2変数のSHAP値の合計**になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_dependence2D(sv, x = \"education_main\", y = \"married_yes\")\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/sv_dependence2D-1.png){width=576}\n:::\n:::\n\n\n\n\n横軸（学歴）をどこにとっても、下側（独身）よりも上側（既婚）のほうが色が明るく、\n前述した、「結婚による加入率上昇はどの学歴層でもみられる」という状況をうまく可視化することが出来ました。\n\nなお、説明変数が地理データである場合には、\n例えば横軸に経度、縦軸に緯度を取るような使い方もあります[@BIB_SHAPVIZ_VIGNETTES_GEOGRAPHIC]。\n\n### SHAP Waterfall Plot\n\n最初に例として挙げた、個別のサンプルに対する寄与の分解[^baseline]をWaterfall Plotといいます。\n\n[^baseline]: このプロットは下端に予測値の平均値がまず現れ、SHAP値（寄与）を順番に足していくと上端の予測値になるという構成になっています。\n             しかし、下端の予測値の平均値は、treeshapパッケージを用いる場合はデフォルトでは必ずゼロが表示される仕様です。\n             何かしらの数値を表示したい場合は、`treeshap`関数の引数`baseline`にその平均値を与える必要があります。\n             加えて、今回は2値分類モデルを構築した（学習時に`objective = \"binary:logistic\"`と指定した）都合上、\n             SHAP値は確率予測値を分解したものではなく、確率予測値をロジット変換したものの分解になっています。\n             このため、上端に表示された予測値は確率予測値そのものにはなっていません。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_waterfall(sv, row_id = 1) #1つ目のサンプルの予測結果に対してプロット\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/sv_waterfall-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### SHAP Force Plot\n\n個別サンプルに対する寄与の分解についてはもう一つプロットが用意されており、\nそれが左側に正方向の寄与、右側に負方向の寄与を一次元的に並べるForce Plotです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_force(sv, row_id = 1) #1つ目のサンプルの予測結果に対してプロット\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/sv_force-1.png){width=576}\n:::\n:::\n\n\n\n\n\n## 発展的な話題\n\n### 対応パッケージ一覧\n\n今回はtreeshapパッケージで計算したSHAPを使用しましたが、\nshapvizパッケージが取り扱えるパッケージは他にもあります。\n\n2024年8月時点で取り扱えるパッケージ・オブジェクトの一覧は次のとおり。\n\n|パッケージ名|クラス名|\n|------|------|\n|xgboost[^shapviz_xgboost]|xgb.Booster|\n|lightgbm|lgb.Booster|\n|h2o|H2ORegressionModel|\n|h2o|H2OBinomialModel|\n|h2o|H2OModel|\n|fastshap|explain|\n|treeshap|treeshap|\n|shapr|explain|\n|kernelshap|kernelshap|\n|kernelshap|permshap|\n|DALEX|predict_parts|\n\n[^shapviz_xgboost]: 実はXGBoostのモデルは、treeshapパッケージを明示的に用いずとも直接`shapviz::shapviz`関数を使用することが出来ます。\n                    本稿では一般的な用法と同じ流れとなるよう、明示的にtreeshapパッケージを用いる形としました。\n\nいずれも`shapviz::shapviz`関数で取り扱うことが出来ますが、引数には多少の差異があります。\n詳細は @BIB_SHAPVIZ_VIGNETTES_BASIC を参照してください。\n\nなお、@BIB_SHAPVIZ_VIGNETTES_BASIC にはSHAP値を格納した一般的なオブジェクトを\nshapvizパッケージに対応させる方法についても記載があります。\n\n### 見た目の調節\n\nshapvizパッケージの関数には見た目の調節を行うための引数がいくつか存在します。\n\nまた、内部的にggplot2パッケージが使用されていることから、\nggplot2の関数を用いた見た目の調節も可能です。\n\n以下、例を示します[^viridis_args]。\n\n[^viridis_args]: 引数`viridis_args`は、`ggplot2::scale_colour_viridis_c`に引き渡される引数をリストで指定するものです。\n                 使用方法の詳細は @BIB_GGPLOT2_VIRIDIS や @BIB_VIRIDIS_INTRO を参照してください。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_importance(sv, kind = \"beeswarm\",\n                       max_display = 6, #6変数まで表示\n                       show_numbers = TRUE, #SHAP Feature Importanceを印字\n                       viridis_args = list(begin = 0.1, end = 0.9, option = \"plasma\")) + #色の設定\n  ggplot2::theme_light()#ggplotのテーマの設定\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/visual_sv_importance-1.png){width=576}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_waterfall(sv, row_id = 1,\n                      max_display = 14, #14変数まで表示\n                      order_fun = function(s) 1:length(s), #並べ方を決める関数…ここでは元の並びを維持\n                      fill_colors = c(\"black\", \"red\"),#正側、負側の色指定\n                      annotation_size = 5) + #下端のE[f(x)]と上端のf(x)の大きさ\n  labs(title = \"SHAP Waterfall Plot\", subtitle = \"row_id = 1\") + #タイトル指定\n  ggplot2::theme(plot.title = element_text(size=16)) #タイトルの大きさ指定\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/visual_sv_waterfall-1.png){width=576}\n:::\n:::\n\n\n\n\n詳しくは各関数のドキュメンテーションを参照してください。\n\n### 複数のSHAP値の取り扱い（mshapbizオブジェクト）\n\n`shapviz::shapviz`関数で作られるオブジェクトはshapvizオブジェクトと呼ばれますが、\n複数のshapvizオブジェクトを内包したmshapvizオブジェクトも存在し、\nこれもshapvizパッケージの関数でプロットすることが可能です。\n\nmshapvizオブジェクトを得る方法はいくつかありますが、\nたとえば`split`関数でshapvizオブジェクトを分割する方法があります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvs <- split(sv, f = df_shap_x$education_main) #education_mainの値ごとに分割\nshapviz::sv_dependence(svs, v = \"age\", color_var = NULL)\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/mshapbiz_split-1.png){width=576}\n:::\n:::\n\n\n\n\n他には、shapvizオブジェクトを`c`関数で結合する方法もあります。\n\nなお、shapvizオブジェクトの分割の際には、\nデータフレーム等と同じような`変数[行, 列]`記法を用いることが出来ます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvs <- c(northeast = sv[df_shap_x$region_midwest+df_shap_x$region_south+df_shap_x$region_west==0, ],\n         midwest = sv[df_shap_x$region_midwest==1, ],\n         south = sv[df_shap_x$region_south==1, ],\n         west = sv[df_shap_x$region_west==1, ])\nshapviz::sv_dependence(svs, v = \"age\", color_var = NULL)\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/mshapbiz_c-1.png){width=576}\n:::\n:::\n\n\n\n\n詳しくは @BIB_SHAPVIZ_VIGNETTES_MULTIPLE を参照してください。\n\n### SHAP交互作用値（SHAP Interaction Plot）\n\nここまでに挙げたグラフは、すべて予測値の加法的な分解としてのSHAP値を様々な切り口でプロットしたものでした。\n\nSHAP値は予測値への寄与を各説明変数に割り振ったものでしたが、\nこれとは別に、（2次の）交互作用への寄与を各2つの説明変数の組に割り振った、**SHAP交互作用値**(SHAP Interaction Values)というものもあります[^shapinteraction]。\n\n[^shapinteraction]: SHAP値は「その説明変数が入力されていない場合とされた場合の予測値の差」の加重平均として計算します。これを、説明変数X, Yの組に対して「X,Y両方入力された場合 - Xが入力されてYが入力されない場合 - Yが入力されてXが入力されない場合 + X,Y両方入力されない場合」の加重平均と置き換えたものがSHAP交互作用値です。\n\nSHAP交互作用値が計算できるパッケージは限られており、2024年8月時点ではtreeshapのみです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt1 <- proc.time()\n#interactionsをTRUEにしておく\nshap_ts <- treeshap::treeshap(obj_uni, x = df_shap_x, interactions = TRUE)\nt2 <- proc.time()\nt0 <- (t2-t1)[3]\nnames(t0) <- NULL\n\ncat(\"処理時間:\", t0, \"秒\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n処理時間: 3.44 秒\n```\n\n\n:::\n\n```{.r .cell-code}\nsv_i <- shapviz::shapviz(shap_ts)\n```\n:::\n\n\n\n\nSummary Plotと同じように、説明変数の組ごとにSHAP交互作用値をプロットするには次のようにします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#重要なものから3つを選び、3x3のプロットを作成\nshapviz::sv_interaction(sv_i, max_display = 3, kind = \"beeswarm\")\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/interaction_sv_interaction-1.png){width=576}\n:::\n:::\n\n\n\n\n（左上から右下に至る）対角線のプロットはSummary Plotと同様に、予測値への寄与が大きさが横軸に示されています。\n残るプロットが説明変数の組に対するSHAP交互作用値を横軸にプロットしたものです。\n\nSHAP値のSummary Plotの場合は、交互作用が「SHAP値＝横軸方向のぶれ」となって表現されていたのに対し、\nこのプロットではSHAP交互作用値へ分解されているため、「ぶれ」が無くなっていることがわかります。\n（たとえば`education_main`のプロットでは、同じ学歴におけるSHAP値が同一となっている）\n\nまた、対角線を挟んで右上側にある3つと左下側にある3つについて、対称な位置にあるもの同士のグラフの形は同じですが、色分けが異なります。\n例えば1行目・2列目のグラフ（`education_main:married_yes`）では学歴（`education_main`）で色分けされており、\n最も低い層と高い層で交互作用が大きくなっていることが読み取れます。\n\nなお、引数`kind`に`\"no\"`を与えた場合、Feature Importanceの類似物として、\nSHAP交互作用値の絶対値の平均値を、行列の形で得ることが出来ます。\n可視化には別の関数が必要です。ここでは`heatmap`関数を用いてみます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_i <- shapviz::sv_interaction(sv_i, kind = \"no\")\nmatrix_i %>% heatmap(Rowv = NA, Colv = NA, revC = TRUE, symm = TRUE, margins = c(8,4))\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/interaction_sv_interaction_no_1-1.png){width=576}\n:::\n:::\n\n\n\n\n今回の例では交互作用があまり無い（XGBoostの予測値は、説明変数ごとに加法的に分解できるモデルとあまり変わらない）ということしか把握できませんでした。\n敢えて対角線要素を除いてプロットするには次のようにします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_i2 <- matrix_i\ndiag(matrix_i2) <- 0\nmatrix_i2 %>% heatmap(Rowv = NA, Colv = NA, revC = TRUE, symm = TRUE, margins = c(8,4))\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/interaction_sv_interaction_no_2-1.png){width=576}\n:::\n:::\n\n\n\n\n\n特定の説明変数の組に着目した分析を行う場合は、\n前述のSHAP Dependence Plotで引数`interactions`に`TRUE`を与えてSHAP交互作用値をプロットします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_dependence(sv_i, v = \"age\", color_var = \"region_west\", interactions = TRUE)\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/interaction_sv_dependence-1.png){width=576}\n:::\n:::\n\n\n\n\n\n前述したような、居住地域が西側の場合、30歳前後での加入率が下がることが表現されています。\n加えて、18歳や60歳以上では逆に加入率が上がるということをも可視化することができました。\n\nなお、今回のモデルは木の構造が比較的単純なため、2次の交互作用ともなるとグラフもかなり単純なものになっています。\n\n`sv_dependence2D`関数版もあります。\n縦軸、横軸に説明変数をとり、SHAP交互作用値で色分けをするというもので、\n先ほどのグラフから単に縦軸と色分けを逆転させただけです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_dependence2D(sv_i, x = \"age\", y = \"region_west\", interactions = TRUE)\n```\n\n::: {.cell-output-display}\n![](shapviz_files/figure-html/interaction_sv_dependence2D-1.png){width=576}\n:::\n:::\n\n\n\n\n\n\n## 参考文献\n\n::: {#refs}\n:::\n",
    "supporting": [
      "shapviz_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
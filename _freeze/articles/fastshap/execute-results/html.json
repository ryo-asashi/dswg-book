{
  "hash": "59ec5f76c350a4de0834cd30135f10f1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"fastshap\"\nauthor: \"データサイエンス関連基礎調査WG\"\ndate: \"2025-08-01\"\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    fig-width: 6\n    fig-height: 5\n    df-print: \"paged\"\nreferences:\n- id: BIB_AER_HEALTHINSURANCE\n  type: article\n  title: \"R: Medical Expenditure Panel Survey Data\"\n  URL: https://search.r-project.org/CRAN/refmans/AER/html/HealthInsurance.html\n  author:\n    - Achim Zeileis\n  issued:\n    - year: 2024\n  accessed:\n    - year: 2024\n      month: 8\n      day: 6\n- id: BIB_FASTSHAP_VIGNETTE\n  type: article\n  title: \"fastshap vignette\"\n  URL: https://cran.r-project.org/web/packages/fastshap/vignettes/fastshap.html\n  author:\n    - Brandon Greenwell\n  issued:\n    - year: 2024\n  accessed:\n    - year: 2024\n      month: 8\n      day: 6\n- id: BIB_STRUMVELJ_2014\n  type: article-journal\n  title: \"Explaining prediction models and individual predictions with feature contributions\"\n  author:\n    - Štrumbelj, Erik\n    - Kononenko, Igor\n  issued:\n    - year: 2014\n  container-title: 'Knowledge and Information Systems'\n  volume: '41'\n  page: 647-655\n  DOI: 10.1007/s10115-013-0679-x\n- id: BIB_BOOK_AER\n  type: book\n  publisher: Springer\n  title: Applied Econometrics with R\n  author:\n    - Christian Kleiber\n    - Achim Zeileis\n  issued:\n    date-parts:\n    - - 2008\n      - 8\n      - 28\n- id: BIB_JOURNAL_IAJ_IML\n  type: article-journal\n  container-title: アクチュアリージャーナル\n  publisher: 日本アクチュアリー会\n  volume: '127'\n  page: 78-117\n  title: Interpretable Machine Learning\n  author:\n    - データサイエンス関連基礎調査WG　大江麗地\n  issued:\n    - year: 2024\n      month: 6\n- id: BIB_MEPS\n  type: article\n  title: \"Medical Expenditure Panel Survey (MEPS) | Agency for Healthcare Research and Quality\"\n  URL: https://www.ahrq.gov/data/meps.html\n  author:\n    - Agency for Healthcare Research and Quality\nnocite: |\n  @*\n---\n\n\n\n\n\n\n## パッケージの概要\n\nfastshapは、予測モデルの解釈手法の一種であるSHAPを、モンテカルロシミュレーションにより計算するパッケージです。\n他のパッケージと比較すると、非常に軽量かつ動作原理がシンプルであるのが特徴です。\n\n### SHAPとは\n\nSHAPという手法については @BIB_JOURNAL_IAJ_IML に解説があるため、こちらを参照することをお勧めします。\n以下では詳細な説明は避け、概要のみを記載します。\n\n**SHAP(SHapley Additive exPlanation)**とは予測モデルの解釈に用いられる手法の一種で、\nある予測モデルの入力（説明変数）と出力（予測値）の組に対して、\n**どの説明変数の寄与によってその予測値となったのかを加法的に分解**するものです。\n\n$$ 個別の予測値 = その予測の説明変数1の寄与 + \\cdots + その予測の説明変数Nの寄与 + 予測値平均$$\n\nこのようにして分解された各サンプル・説明変数の寄与を**SHAP値**と呼びます。\n\n個別サンプルの予測に対する解釈を与える、いわゆるローカルな手法だと考えられますが、\n多くのサンプルのSHAPを計算してそれをグラフにする、平均値で要約する等により、\nモデル全体の解釈を与える、いわゆるグローバルな手法としても使用することが出来ます。\n\n### fastshapの特徴\n\n説明変数ごとの寄与は、「その説明変数が**入力されていない場合とされた場合の予測値の差**」の（加重）平均で計算されます。\nしかし、実際には「ある説明変数だけ予測モデルに入力しない」ということは通常出来ないため、\n条件付期待値や、その説明変数を実データからランダムに選び出したときの予測値の平均のようなものを当てはめることとなります。\nそのうえで、例えばN個の説明変数がある場合は、入力されているかどうかの組み合わせは$2^N$通りあることになるので、\n**たった1サンプルに対して、予測値の平均値のようなものを$2^N$通り分計算**する必要があります。\n\n1サンプルならまだしも、グローバルな手法として使用するために多数のサンプルで計算する場合は計算量が莫大なものとなります。\nそこで高速に計算する手法がいくつか提案されており、\nそのうち fastshap は @BIB_STRUMVELJ_2014 によって提案されるモンテカルロシミュレーションによる近似を実装したものです。\n\n原理は非常にシンプルで、例えばあるサンプルのk番目の説明変数の寄与を計算する場合、\n\n- 「入力」する説明変数の数をランダムに決める（個数に関して一様な分布）\n- その数だけ、「入力」する説明変数をk番目以外からランダムに選び出す\n- k番目以外の説明変数について、「入力」する説明変数はそのサンプルそのまま、「入力」しない説明変数は全サンプルからランダムに選ぶ\n- k番目の説明変数について「入力」した場合と「入力」しない（全サンプルからランダムに選んだ）場合の2回の予測を計算し、その差分を取る\n- この操作を複数回行い、差分の平均値をk番目の説明変数の寄与とする\n\nという流れになります。\n\n全サンプルのSHAPを計算したとしても予測を行う回数が 説明変数の数×2×試行回数×用意したサンプルの数 となり、\n現実的な計算時間でグローバルな手法としてのSHAPを用いることが可能です。\nただし、特徴量の数・サンプル数によっては計算値を収束させるほど試行回数を増やすのは現実的ではないこともあるため、\n**あくまで近似値を計算するものと捉えるべき**でしょう。\n\nなお、乱数の適用にC++を使用する、並列処理に対応させるという工夫により高速化を図っているのも本パッケージの特徴です。\n\n## 準備\n\n### パッケージの読み込み\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(AER) #データセット\n\nlibrary(tibble) #data.frame拡張版\nlibrary(dplyr) #data.frameの操作\nlibrary(rsample) #データ分割\nlibrary(recipes) #前処理\n\nlibrary(xgboost) #今回使用するモデルのパッケージ\nlibrary(ranger)\nlibrary(glmnet)\n\nlibrary(ROCR) #精度評価\n\nlibrary(fastshap) #SHAPを計算できるパッケージ群\nlibrary(treeshap)\nlibrary(kernelshap)\nlibrary(DALEX)\n\nlibrary(foreach) #並列計算による高速化\nlibrary(doParallel)\n\nlibrary(ggplot2) #グラフの描画\nlibrary(patchwork) #複数のgpplotを組み合わせる\nlibrary(shapviz) #SHAPの可視化\n```\n:::\n\n\n\n\n\n### データセットの読み込み\n\n@BIB_BOOK_AER で使用されたデータセット等をまとめたパッケージAERに含まれる、\nHealthInsuranceというデータセットを使用します。\n\n性別・年齢・学歴・家族構成・雇用状態（自営業か否か）健康保険の加入状況等に関する\n約9,000個のサンプルが含まれています。\n今回は、健康保険に加入しているかどうかを予測するモデルを作成することとします。\n\nデータセットの詳細については @BIB_AER_HEALTHINSURANCE を参照してください[^dataset]。\n\n[^dataset]: 元の研究は、自営業者の健康保険加入率の低さと健康状態の関係性を調べたものです。この研究で用いられた、1996年の米国医療費パネル調査(MEPS[@BIB_MEPS])から抽出されたものがこのデータセットです。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"HealthInsurance\")\ndf_all <- HealthInsurance\n\nsummary(df_all)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n health          age        limit         gender     insurance  married   \n no : 629   Min.   :18.00   no :7571   female:4169   no :1750   no :3369  \n yes:8173   1st Qu.:30.00   yes:1231   male  :4633   yes:7052   yes:5433  \n            Median :39.00                                                 \n            Mean   :38.94                                                 \n            3rd Qu.:48.00                                                 \n            Max.   :62.00                                                 \n                                                                          \n selfemp        family             region     ethnicity         education   \n no :7731   Min.   : 1.000   northeast:1682   other: 365   none      :1119  \n yes:1071   1st Qu.: 2.000   midwest  :2023   afam :1083   ged       : 374  \n            Median : 3.000   south    :3075   cauc :7354   highschool:4434  \n            Mean   : 3.094   west     :2022                bachelor  :1549  \n            3rd Qu.: 4.000                                 master    : 524  \n            Max.   :14.000                                 phd       : 135  \n                                                           other     : 667  \n```\n\n\n:::\n:::\n\n\n\n\n### 前処理\n\n今回例として使用するモデルでは、説明変数が数値型である必要があるので、factor型変数を数値型に変換しておきます[^prep]。\n\n[^prep]:なお、ここではデータ前処理にrecipesパッケージを使用しています。\n        また、`%>%`はmagrittrパッケージによるパイプ演算子で、右辺の関数の第1引数に左辺を渡すという働きがあります。\n        たとえば`a %>% f %>% g(b)`という記述は`g(f(a),b)`と同等です。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_init <- df_all %>% recipe(insurance ~ .) %>% #前処理手順の定義\n  #ethinicityは最も多いカテゴリがcaucなので、これを基準カテゴリに変更\n  step_relevel(ethnicity, ref_level = \"cauc\") %>% \n  #educationは学歴を表す説明変数で、大きいほど高学歴であるため、そのままダミー変数にするのではなく、数値に変換\n  step_mutate(education_main = as.numeric(education) - 1) %>%\n  #ただし、最後のカテゴリだけは「その他」を表しているので、これだけは別のダミー変数に分離する\n  step_mutate(education_other = if_else(education_main == 6, 1, 0)) %>%\n  step_mutate(education_main = if_else(education_main < 6, education_main, 0)) %>%\n  step_rm(education) %>%\n  step_dummy(all_factor_predictors()) %>% #他のfactor型変数は単純にダミー変数化\n  step_relevel(insurance, ref_level = \"yes\")\n  #目的変数は健康保険に加入しているかを表すinsurance\n\ndf_baked <- rec_init %>% prep() %>% bake(new_data = NULL) #上記で定義した前処理手順を実際に実行\n```\n:::\n\n\n\n\n上記前処理を施したうえで、学習データとテストデータに分割します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\nsplit_df <- rsample::initial_split(df_baked, prop = 0.8) #80%を学習データ、20%をテストデータとする\ndf_train <- rsample::training(split_df)\ndf_test <- rsample::testing(split_df)\n\ndf_train_x <- df_train %>% dplyr::select(-insurance)\ndf_train_y <- df_train$insurance\ndf_test_x <- df_test %>% dplyr::select(-insurance)\ndf_test_y <- df_test$insurance\n```\n:::\n\n\n\n\n### モデル構築\n\n続いてXGBoostによる予測モデルを学習データをもとに構築します。[^omittune]\n\n2値分類の問題ですが、予測モデルの出力としては加入しているか否かの2通りではなく、\n加入している確率を出力するようにしています。\n\n[^omittune]:ハイパーパラメータは事前にチューニングしたものを入力しています。\n            チューニングの過程については本稿の主題を外れるので、割愛します。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\nmodel_xgboost <- xgboost(data = as.matrix(df_train_x), label = as.matrix(2 - as.numeric(df_train_y)), nrounds = 100,\n                  params = list(eta = 0.3, max_depth = 2, gamma = 0, min_child_weight = 1, \n                             subsample = 1, colsample_bytree = 1, colsample_bynode = 2/14, objective = \"binary:logistic\"),\n                  verbose = 0)\n```\n:::\n\n\n\n\n\n構築した予測モデルの精度をテストデータを用いて確認しておきます。\n\nまずはAUC(ROC)を確認します。これは2値分類モデルで使用される評価指標で、高いほど精度が良いという評価になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_logloss <- function(act, pred){mean(-act *log(pred)-(1-act)*log(1-pred))}\ncalc_score <- function(object, predfun, df_test_x, df_test_y){\n  yhat <- object %>% predfun(df_test_x)\n  pr <- ROCR::prediction(yhat, df_test_y)\n  auc <- pr %>% ROCR::performance(\"auc\")\n  auc_plot <- pr %>% ROCR::performance(\"tpr\", \"fpr\")\n  list(\n    auc_plot = auc_plot,\n    auc = auc@y.values %>% as.numeric(),\n    logloss = calc_logloss(act = 2 - as.numeric(df_test_y), pred = yhat)\n    )\n}\n\npredfun_xgboost <- function(object, newdata){\n  dt <- as.matrix(newdata)\n  object %>% predict(newdata = dt)\n}\nscore <- calc_score(model_xgboost, predfun_xgboost, df_test_x, df_test_y)\nscore$auc_plot %>% plot()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/xgb_test-1.png){width=576}\n:::\n\n```{.r .cell-code}\nscore$auc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7503933\n```\n\n\n:::\n:::\n\n\n\n\n0.75は高くもなく低くもないといった程度ではあるものの、用途によってはこれでも十分でしょう。\n（例えば True Positive Rate = 0.6, False Positive Rate = 0.2 あたりとなるしきい値をとれば、\n　全体の8割程度を占める加入者のうち6割を削減しつつ、少数派の非加入者のうち8割を残した集団が作れる）\n　\n　\n後で他のモデルと比較する際の参考のため、LogLossスコアも計算しておきます。\nこちらは出力される確率値の正確性を評価するもので、低いほうが精度が良いという評価になります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#後で別のモデルと比較するため、スコアをデータフレームに格納\ndf_scores <- tibble(model = \"xgboost\", auc = score$auc, logloss = score$logloss)\nscore$logloss\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4424059\n```\n\n\n:::\n:::\n\n\n\n\n## fastshapの使用方法\n\n### 基本的な使用方法\n\nまず、実際にSHAPを計算したいサンプルと、SHAP計算時に「入力しない説明変数」のためにランダムで選ぶ元になるサンプルを選びます。\nこの両者は同じでもよいですが、前者は数百件程度が一応の目安です。\n後者は計算パフォーマンス次第ですが、前者を多めに取りたい場合は前者よりも少なめにします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024) #SHAPを計算したいサンプル\nnrow_shap <- 100\ndf_shap <- df_train[sample(nrow(df_train), nrow_shap), ]\ndf_shap_x <- df_shap %>% dplyr::select(-insurance)\n\nset.seed(2024+1) #ランダムで選ぶ元になるサンプル\nnrow_shapbg <- 30\ndf_shapbg <- df_train[sample(nrow(df_train), nrow_shapbg), ]\ndf_shapbg_x <- df_shapbg %>% dplyr::select(-insurance)\n```\n:::\n\n\n\n\n次に、explain関数で実際にSHAPを計算します。\n\nここで、0から1の確率値を加法的に分解するよりも、\nロジット変換により実数全体の数値に変換してから分解したほうが説明変数ごとの寄与を比較する際には有用と考えられます。\n\npredict関数で出力される確率値をロジット変換したものを出力する関数を作成し、\n引数`pred_wrapper`にこの関数を指定することでこれを実現することが出来ます。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogit <- function(x) log(x) - log(1-x) \npredfun_xgboost_logit <- function(object, newdata){ #predict関数の結果をロジット変換する関数\n  predfun_xgboost(object, newdata) %>% logit()\n}\n\nt1 <- proc.time()\nset.seed(2024)\nshap_fs <- fastshap::explain(model_xgboost, #予測モデルのオブジェクト\n                             X = df_shapbg_x, #ランダムで選ぶもとになるサンプル\n                             # SHAPを計算したいサンプル　こちらは厳密にdata.frame型でないとエラー(バグ?)\n                             newdata = as.data.frame(df_shap_x),\n                             pred_wrapper = predfun_xgboost_logit, #予測値を生成する関数\n                             nsim = 10, #試行回数\n                             parallel = FALSE) #並列処理の設定\nt2 <- proc.time()\nt0 <- (t2-t1)[3]\nnames(t0) <- NULL\n\ncat(\"処理時間:\", t0, \"秒\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n処理時間: 2.07 秒\n```\n\n\n:::\n:::\n\n\n\n\n最後にこれを可視化します。これにはshapvizパッケージを用いるとよいでしょう。\nまず、個別のサンプルに対する寄与の分解を表示するには次のようにします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsv <- shapviz::shapviz(shap_fs, X = df_shap_x) #shapvizパッケージで可視化できるオブジェクトに変換\nshapviz::sv_waterfall(sv, row_id = 1) #1つ目のサンプルの予測結果に対してプロット\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/basic_shapviz-1.png){width=576}\n:::\n:::\n\n\n\n\nこのサンプルでは、自営業であること（`selfemp_yes=1`）や独身である（`married_yes=0`）ことによって、\n平均的な被験者よりも健康保険に加入しない傾向にあると判断されたようです。\n\nまた、グローバルな手法として全サンプルの結果を一覧に表示し、\n説明変数ごとに全般的にどの程度寄与しているかをプロットするには次のようにします。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapviz::sv_importance(sv, kind = \"beeswarm\")\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/basic_shapviz_sfi-1.png){width=576}\n:::\n:::\n\n\n\n\n横軸は寄与の大きさを、色付けは説明変数の値を示しており、\n例えば明るい色の点が右側にある場合は、その説明変数が高いほど予測確率が高くなることを示します。\n\n`shapviz::sv_importance`関数はデフォルトでは寄与が大きい説明変数から順に並べられるので、\n最も予測確率への寄与が大きい説明変数は学歴（`education_main`）であることがわかります。\nまた、学歴が高いほど健康保険に加入する傾向があることがわかります。\n\n\n### 並列計算\n\nfastshapにはforeachパッケージによる並列計算が実装されています。\n\n事前にdoParallelパッケージの関数を使用して適切に並列計算の設定を行ったのちに、\n引数`parallel`を`TRUE`にしたうえで、`foreach`関数に渡したい引数を追加することで並列計算が可能になります。\n\nforeachパッケージによる並列計算の際は複数の独立したR環境が生成されますが、\nその環境に引き渡すべきパッケージや関数は明示的に指定する必要があることに注意してください。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster <- makeCluster(detectCores()-1)\nregisterDoParallel(cluster)\n\nt1 <- proc.time()\nset.seed(2024)\nshap_fs <- fastshap::explain(model_xgboost,\n                             X = df_shapbg_x,\n                             newdata = as.data.frame(df_shap_x),\n                             pred_wrapper = predfun_xgboost_logit,\n                             nsim = 100,\n                             parallel = TRUE,\n                             #独立したR環境に引き渡すべきパッケージや関数を記述\n                             .packages=c('dplyr'), .export=c(\"logit\", \"predfun_xgboost\"))\nt2 <- proc.time()\nt <- (t2-t1)[3]\nnames(t) <- NULL\n\ncat(\"処理時間:\", t, \"秒\")\n\nstopCluster(cluster)\n```\n:::\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n処理時間: 10.97 秒\n```\n\n\n:::\n:::\n\n\n\n\n並列計算しない場合は10回の試行に2.07秒かかっていました。\n上記では試行回数を100回に増やしましたが、並列計算の恩恵によってその10倍よりは短い時間で計算できています。\n\nなお、どのような状況であっても並列計算で劇的に高速化する訳ではなく、また環境によって効果は異なってくる点に注意してください。\n\n\nちなみに、`shapviz::sv_importance`関数の結果は次のとおりであり、\n試行回数を増やすことによって計算結果が収束してきていることがわかります。\n逆に、試行回数10回では流石に少なすぎるかもしれません。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsv <- shapviz::shapviz(shap_fs, X = df_shap_x)\nshapviz::sv_importance(sv, kind = \"beeswarm\")\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/foreach_2-1.png){width=576}\n:::\n:::\n\n\n\n\n### 引数adjustによる局所正確性の確保\n\n説明変数ごとの寄与を積み上げると元の予測値になるというSHAPの性質を局所正確性（local accuracy）といいます。\nしかし、fastshapは近似的な手法のため、そのままでは局所正確性が満たされないという弱点があります。\n引数`adjust`を`TRUE`にすることで、局所正確性を確保できるように補正することができます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\nshap_fs_notadjusted <- fastshap::explain(model_xgboost,\n                             X = df_shapbg_x,\n                             newdata = as.data.frame(df_shap_x),\n                             pred_wrapper = predfun_xgboost_logit,\n                             nsim = 4,\n                             parallel = FALSE,\n                             adjust = FALSE)\nsv_notadjusted <- shapviz::shapviz(shap_fs_notadjusted, X = df_shap_x)\n\nset.seed(2024)\nshap_fs_adjusted <- fastshap::explain(model_xgboost,\n                             X = df_shapbg_x,\n                             newdata = as.data.frame(df_shap_x),\n                             pred_wrapper = predfun_xgboost_logit,\n                             nsim = 4,\n                             parallel = FALSE,\n                             adjust = TRUE)\nsv_adjusted <- shapviz::shapviz(shap_fs_adjusted, X = df_shap_x)\n\n\n(shapviz::sv_waterfall(sv_notadjusted, row_id = 1) + ggtitle(\"補正前\")) +\n(shapviz::sv_waterfall(sv_adjusted, row_id = 1)  + ggtitle(\"補正後\"))\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/adjust-1.png){width=576}\n:::\n\n```{.r .cell-code}\ncat(\"実際の予測値（のロジット変換後）:\", predfun_xgboost_logit(model_xgboost, df_shap_x[1, ]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n実際の予測値（のロジット変換後）: -0.1223738\n```\n\n\n:::\n:::\n\n\n\n\n補正後は、プロットの上部にあるf(x)の値が実際の予測値と一致していることが確認できます。\n\n### 引数exactによる理論値の計算\n\n引数`exact`を`TRUE`にした場合、次のモデルに限り、\nモンテカルロシミュレーションを行うのではなくパラメータから理論的な値を計算することができます。\n\n- `stats::lm()` ：線形回帰モデル…最初から加法的に関数が分解されているため、係数×説明変数を計算すればよい\n- `xgboost::xgboost()`, `lightgbm::lightgbm()` ：ブースティング木モデル…Tree SHAPを用いる\n\nXGBoostの場合を示すと次のとおり。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt1 <- proc.time()\nset.seed(2024)\nshap_exact <- fastshap::explain(model_xgboost,\n                             X = as.matrix(df_shap_x),\n                             exact = TRUE,\n                             parallel = FALSE)\nt2 <- proc.time()\nt0 <- (t2-t1)[3]\nnames(t0) <- NULL\n\ncat(\"処理時間:\", t0, \"秒\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n処理時間: 0.12 秒\n```\n\n\n:::\n:::\n\n\n\n\n`shapviz::sv_importance`関数で可視化してみると次のとおりです。[^xgb]\n\n[^xgb]:実はXGBoostの場合fastshapパッケージを用いずとも直接shapvizパッケージによる可視化を行うことが出来るので、実用性はあまりありません。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsv_exact <- shapviz::shapviz(shap_exact, X = df_shap_x)\nshapviz::sv_importance(sv_exact, kind = \"beeswarm\")\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/exact_shapviz-1.png){width=576}\n:::\n:::\n\n\n\n\n## 他のパッケージとの比較\n\nSHAPの計算を実装したパッケージは他にもいくつかあり、代表的なものを比較して整理すると次のようになります。\n\n| パッケージ名 | 概要 | 対応モデル | 計算速度 | 計算精度 |\n|------|--------------------|------------|--------|------|\n| fastshap | モンテカルロシミュレーションによる計算 | すべての予測モデル | 高速 | 低い |\n| kernelshap | Kernel SHAPの高速な実装 | すべての予測モデル | 普通| 高い |\n| treeshap | Tree SHAP | ランダムフォレスト、ブースティング木| 非常に高速 | 高い |\n| DALEX | 他の手法(breakdown等)も統合的に扱える | すべての予測モデル | 非常に低速 | 高い |\n\n最も高速なのはTree SHAPを実装したtreeshapです。\n\nTree SHAPは、決定木の場合は条件付期待値の理論値が予測モデルのパラメータから計算可能であり、\nさらにアンサンブルモデルの場合には平均値でSHAPを計算できるという特徴によって高速に計算する手法です。\nそのため、対応しているのはランダムフォレストやブースティング木を実装した一部のパッケージに限られます。\n\nそれ以外のモデルの場合、kernelshapは計算精度の高さと計算速度をある程度両立してはいるものの、\nサンプル数や説明変数の数が多い場合には実行が難しい場合もあります。\n\nこれらに比べてfastshapは非常に軽量かつシンプルなため、\n利用者側で精度と計算速度の調整が行いやすいという点が特徴と言えます。\n\nDALEXはSHAP以外の他の解釈手法をも統合的に扱える点が特徴ですが、\n計算速度は低速であり、グローバルな手法としては扱いづらいかもしれません。\nグローバルな手法として用いる場合はshapvizパッケージが使用できない（2024.8時点）という弱点もあります。\n\n### kernelshapの例\n\n今回の例の場合はfastshapで並列計算を採用するよりも、高速で良い結果が得られているように思われます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt1 <- proc.time()\nset.seed(2024)\nshap_ks <- kernelshap::kernelshap(model_xgboost, X = df_shap_x, bg_X = df_shapbg_x,\n                                  pred_fun = predfun_xgboost_logit)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nKernel SHAP values by the hybrid strategy of degree 2\n```\n\n\n:::\n\n```{.r .cell-code}\nt2 <- proc.time()\nt0 <- (t2-t1)[3]\nnames(t0) <- NULL\n\ncat(\"処理時間:\", t0, \"秒\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n処理時間: 3.16 秒\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsv <- shapviz::shapviz(shap_ks) #kernelshapの場合引数Xは不要\nshapviz::sv_importance(sv, kind = \"beeswarm\")\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/kernelshap_shapviz-1.png){width=576}\n:::\n:::\n\n\n\n\n### DALEXの例\n\nDALEXの場合はshapvizで可視化できるのは個別サンプルの寄与を計算する`DALEX::predict_parts`関数のみで、\nグローバルな手法で用いる`DALEX::shap_aggregated`関数は対応していません。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexplainer <- DALEX::explain(model_xgboost,\n                     data = df_shapbg_x,\n                     predict_function = predfun_xgboost_logit,\n                     quietly = TRUE,\n                     verbose = FALSE)\n\nt1 <- proc.time()\nset.seed(2024)\nshap_dalex <- DALEX::predict_parts(explainer, df_shap_x[1, ], type = 'shap')\nt2 <- proc.time()\nt0 <- (t2-t1)[3]\nnames(t0) <- NULL\n\ncat(\"処理時間:\", t0, \"秒\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n処理時間: 1.97 秒\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsv_dalex <- shapviz::shapviz(shap_dalex)\nshapviz::sv_waterfall(sv_dalex, row_id = 1)\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/DALEX_shapviz-1.png){width=576}\n:::\n:::\n\n\n\n\nさらに、`DALEX::shap_aggregated`関数は計算時間が非常に長く、実用的とはいえません。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_shap_x_dalex <- df_shap_x\n#DALEX::shap_aggregatedには説明変数の型がすべて同じではエラーになるバグがある（2024.8時点）ため、\n#一つだけ別の型（numericからinteger）に変換しておく\ndf_shap_x_dalex$education_main <- as.integer(df_shap_x$education_main)\ndf_shap_x_dalex <- df_shap_x_dalex[1:4, ] #あまりにも計算時間が長いので、4サンプルに限定\n\nexplainer <- DALEX::explain(model_xgboost,\n                     data = df_shapbg_x,\n                     predict_function = predfun_xgboost_logit,\n                     quietly = TRUE,\n                     verbose = FALSE)\n\nt1 <- proc.time()\nset.seed(2024)\nshap_dalex_agg <- DALEX::shap_aggregated(explainer, df_shap_x_dalex, type = 'shap', B = 10) #Bは試行回数\nt2 <- proc.time()\nt0 <- (t2-t1)[3]\nnames(t0) <- NULL\n\ncat(\"処理時間:\", t0, \"秒\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n処理時間: 2.9 秒\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshap_dalex_agg %>% plot()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/unnamed-chunk-1-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### 他のモデルの例\n\n#### GLM\n\n最も単純な予測モデルの例として、ロジスティック回帰の例を用意します。\n\n実は単純なロジスティック回帰でもそれなりの予測精度になります。\n最も重要な説明変数である学歴については単純に学歴の低いものから0, 1, 2, ...と並べて数値に変換しただけですが、\nこれでも非常によくフィットします。\n前述までのSHAPによるグローバルな分析にて、`education_main`の点がおおむね等間隔に群団を作っていたことと整合します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_glm <- glm(insurance ~ ., data = df_train, family = \"binomial\")\npredfun_glm <- function(object, newdata){\n  res <- object %>% predict(newdata = newdata, type = \"response\")\n  1 - res\n}\npredfun_glm_logit <- function(object, newdata){\n  res <- object %>% predict(newdata = newdata, type = \"link\")\n  -res\n}\nscore <- calc_score(model_glm, predfun_glm, df_test_x, df_test_y)\ndf_scores <- df_scores %>% bind_rows(tibble(model = \"glm\", auc = score$auc, logloss = score$logloss))\n\nscore$auc_plot %>% plot()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/glm_fit-1.png){width=576}\n:::\n\n```{.r .cell-code}\ncat(\"auc:\", score$auc, \"logloss:\", score$logloss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nauc: 0.7400438 logloss: 0.4504438\n```\n\n\n:::\n:::\n\n\n\n\n#### 特徴量エンジニアリングを加えた（正則化）GLM\n\n特徴量エンジニアリング（説明変数の加工）を行うことで、非線形な作用をGLMで捉えられるようになります。\nこの場合はモデル自身の係数が複雑になってしまい解釈可能性が低下してしまうので、\nSHAPのような手法を駆使して解釈することは考えられます。\n\nTree SHAPを用いることができない例として、この特徴量エンジニアリングを加えたGLMを用意します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecp_glm_prep <- df_train %>% recipe(insurance ~ .) %>%\n  #高学歴層では等間隔とならないことへの対応\n  step_mutate(education_geq_4 = 1*(education_main >= 4)) %>% \n  #年齢が非常に複雑に作用することを捉える\n  step_mutate(age_geq_20 = 1*(age >= 20)) %>% \n  step_mutate(age_geq_24 = 1*(age >= 24)) %>%\n  step_mutate(age_geq_26 = 1*(age >= 26)) %>%\n  step_mutate(age_geq_27 = 1*(age >= 27)) %>%\n  step_mutate(age_geq_57 = 1*(age >= 57)) %>%\n  step_mutate(age_geq_58 = 1*(age >= 58)) %>% \n  #家族の数もわずかに非線形な作用がある\n  step_mutate(family_geq_2 = 1*(family >= 2)) %>%\n  step_mutate(family_geq_3 = 1*(family >= 3)) %>%\n  step_mutate(family_geq_7 = 1*(family >= 7)) %>%\n  step_mutate(family_geq_11 = 1*(family >= 11)) %>%\n  step_mutate(family_geq_12 = 1*(family >= 12)) %>%\n  #重要な説明変数に関連する交互作用項を追加\n  step_interact(terms = ~ (tidyselect::starts_with(\"age\") + tidyselect::starts_with(\"education_\") +\n                       married_yes + selfemp_yes + education_other)*all_numeric_predictors(), sep = \":\") %>%\n  prep()\n\ndf_train_x_glm_prep <- recp_glm_prep %>% bake(new_data = df_train_x)\n\nlambda_glm_prep <- 0.0036 #正則化項の係数\n#交互作用項が多数作られてしまうので、Lasso回帰による変数選択を組み合わせる\nmodel_glm_prep <- glmnet::glmnet(x = df_train_x_glm_prep, y = 2 - as.numeric(df_train_y),\n                                 alpha = 1, lambda = lambda_glm_prep, family = \"binomial\")\n\n#予測関数の中に上記前処理を行う処理を差し込むことで\n#他のモデルと同じ形式のデータフレームを入力できるようにしておく\npredfun_glm_prep <- function(object, newdata){\n  df <- recp_glm_prep %>% bake(new_data = newdata)\n  res <- object %>% predict(newx = as.matrix(df), type = \"response\")\n  res[,1]\n}\npredfun_glm_prep_logit <- function(object, newdata){\n  df <- recp_glm_prep %>% bake(new_data = newdata)\n  res <- object %>% predict(newx = as.matrix(df), type = \"link\")\n  res[,1] #ベクトルにしておかないとfastshapの計算に失敗する\n}\n\nscore <- calc_score(model_glm_prep, predfun_glm_prep, df_test_x, df_test_y)\ndf_scores <- df_scores %>% bind_rows(tibble(model = \"glm_prep\", auc = score$auc, logloss = score$logloss))\n\nscore$auc_plot %>% plot()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/glm_prep_fit-1.png){width=576}\n:::\n\n```{.r .cell-code}\ncat(\"auc:\", score$auc, \"logloss:\", score$logloss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nauc: 0.7446471 logloss: 0.4475717\n```\n\n\n:::\n:::\n\n\n\n\n#### rangerによるランダムフォレスト\n\nTree SHAPが使用できる他の例として、rangerパッケージのランダムフォレストを用意します。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\ndf_train_ranger <- df_train\ndf_train_ranger$insurance <- 2 - as.numeric(df_train_ranger$insurance)\nmodel_ranger <- ranger::ranger(formula = insurance ~ ., data = df_train_ranger, \n                               importance = 'none', #probability = TRUE,\n                               num.trees = 100, min.node.size = 40, mtry = 4)\n#分類問題の場合はprobability = TRUEとすべきだが、treeshap::unifyでエラーとなるため通常の回帰モデルとする\n\npredfun_ranger <- function(object, newdata){\n  res <- object %>% predict(data = newdata)\n  res$predictions\n}\npredfun_ranger_logit <- function(object, newdata){ #predict関数の結果をロジット変換する関数\n  predfun_ranger(object, newdata) %>% logit()\n}\n\nscore <- calc_score(model_ranger, predfun_ranger, df_test_x, df_test_y)\ndf_scores <- df_scores %>% bind_rows(tibble(model = \"ranger\", auc = score$auc, logloss = score$logloss))\n\nscore$auc_plot %>% plot()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/ranger_fit-1.png){width=576}\n:::\n\n```{.r .cell-code}\ncat(\"auc:\", score$auc, \"logloss:\", score$logloss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nauc: 0.7360556 logloss: 0.4536576\n```\n\n\n:::\n:::\n\n\n\n\n#### 予測モデルの精度比較\n\n本稿の主題を外れるため、各予測モデルの解釈を比較したりはしませんが、\nいずれもうまく学習できているということを確かめるために\nXGBoostと比較しても精度があまり変わらないということを確認しておきます。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_scores\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"model\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"auc\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"logloss\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"xgboost\",\"2\":\"0.7503933\",\"3\":\"0.4424059\"},{\"1\":\"glm\",\"2\":\"0.7400438\",\"3\":\"0.4504438\"},{\"1\":\"glm_prep\",\"2\":\"0.7446471\",\"3\":\"0.4475717\"},{\"1\":\"ranger\",\"2\":\"0.7360556\",\"3\":\"0.4536576\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n\n\n### 計算時間比較\n\n\n\n\n\n\n\n\n\n\n\n\n\nここまでに用意した4つのモデル（XGBoost、rangerによるランダムフォレスト、GLM、特徴量エンジニアリング付GLM）に対して、\nfastshap、kernelshap、treeshapによるSHAPの計算時間を比較してみます。\n\nSHAPを計算するサンプル数を増やした時に計算時間がどのように変化するかをプロットすると次のとおり。\n（treeshap以外で使用する`nrow_shapbg`は50、fastshapの試行回数は10）\n\nサンプル数を増やしてもfastshapはあまり計算時間が増えませんが、\nkernelshapは比例的に計算時間が増加します。\ntreeshapは非常に高速ですが、rangerではツリーの構造のためなのか、サンプル数を増やすとfastshapと逆転します。\n\n特徴量エンジニアリング付きGLM（`glm_prep`）は予測関数を呼び出すたびに前処理を実行するため、\n他のモデルと比べて計算時間が長くなっています。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = results %>% dplyr::filter(nrow_shapbg <= 50, nsim <= 10),\n       mapping = aes(x = nrow_shap, y = time, color = model, linetype = method)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/comp_nrow_shap-1.png){width=576}\n:::\n:::\n\n\n\n\n特徴量エンジニアリング付きGLMを除くと次のとおり。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = results %>% dplyr::filter(nrow_shapbg <= 50, nsim <= 10, model != \"glm_prep\"),\n       mapping = aes(x = nrow_shap, y = time, color = model, linetype = method)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/comp_nrow_shap_1-1.png){width=576}\n:::\n:::\n\n\n\n\nさらにXGBoostに着目すると次のとおり。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = results %>% dplyr::filter(nrow_shapbg <= 50, nsim <= 10, model == \"xgboost\"),\n       mapping = aes(x = nrow_shap, y = time, color = model, linetype = method)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/comp_nrow_shap_xgb-1.png){width=576}\n:::\n:::\n\n\n\n\n横軸を`nrow_shapbg`（「入力しない説明変数」のためにランダムで選ぶ元になるサンプル数）とすると次のとおり。\nkernelshapではおおむね件数に比例して計算時間が増加しています。\n一方fastshapではSHAPを計算するサンプル数ほど計算時間との関係性が明確ではありませんでした。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = results %>% dplyr::filter(nrow_shap == 50, nrow_shapbg >= 50, nsim <= 10),\n       mapping = aes(x = nrow_shapbg, y = time, color = model, linetype = method)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/comp_nrow_shapbp-1.png){width=576}\n:::\n:::\n\n\n\n\nfastshapの試行回数を横軸にとると、計算時間は試行回数と正比例していることがわかります。\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = results %>% dplyr::filter(nrow_shap == 50, nrow_shapbg == 50, nsim >= 10),\n       mapping = aes(x = nsim, y = time, color = model, linetype = method)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](fastshap_files/figure-html/comp_nsim-1.png){width=576}\n:::\n:::\n\n\n\n\n参考までに、上記グラフを作成するためのコードは次のとおりです。\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#計算時間比較をしたいモデルの定義\nmodelsets <- list()\n\nmodelsets$glm <- list(object = model_glm, predfun = predfun_glm_logit)\nmodelsets$glm_prep <- list(object = model_glm_prep, predfun = predfun_glm_prep_logit)\nmodelsets$xgboost <- list(object = model_xgboost, predfun = predfun_xgboost_logit)\nmodelsets$ranger <- list(object = model_ranger, predfun = predfun_ranger_logit)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#計算パターンの定義\ngrid <- bind_rows(\n          tidyr::expand_grid(\n            model = c(\"glm\", \"glm_prep\", \"xgboost\", \"ranger\"),\n            bind_rows(\n              tidyr::expand_grid(\n                method = \"kernelshap\",\n                bind_rows(tidyr::expand_grid(nrow_shap = seq(1,5)*50, nrow_shapbg = 50, nsim = 10),\n                          tidyr::expand_grid(nrow_shap = 50, nrow_shapbg = seq(2,5)*50, nsim = 10))\n              ),\n              tidyr::expand_grid(\n                method = \"fastshap\",\n                bind_rows(tidyr::expand_grid(nrow_shap = seq(1,5)^2*50, nrow_shapbg = 50, nsim = 10),\n                          tidyr::expand_grid(nrow_shap = 50, nrow_shapbg = seq(2,5)^2*50, nsim = 10),\n                          tidyr::expand_grid(nrow_shap = 50, nrow_shapbg = 50, nsim = seq(2,5)*10))\n              )\n            )\n          ),\n          tidyr::expand_grid(\n            model = c(\"xgboost\", \"ranger\"),\n            tidyr::expand_grid(\n              tidyr::expand_grid(\n                method = \"treeshap\",\n                bind_rows(tidyr::expand_grid(nrow_shap = seq(1,5)^2*50, nrow_shapbg = 0, nsim = 10))\n              )\n            )\n          )\n        )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#計算パターン1つに対して計算時間を測る関数\ncalc_shap <- function(object, predfun, method, nrow_shap = 500, nrow_shapbg = 60, nsim = 1){\n  t1 <- proc.time()\n  \n  set.seed(2024)\n  df_shap <- df_train[sample(nrow(df_train), nrow_shap), ]\n  df_shap_x <- df_shap %>% dplyr::select(-insurance)\n  \n  set.seed(2024+1)\n  df_shapbg <- df_train[sample(nrow(df_train), nrow_shapbg), ]\n  df_shapbg_x <- df_shapbg %>% dplyr::select(-insurance)\n\n  nsim_res <- 0\n  nrow_shapbg_res <- nrow_shapbg\n\n  if(method == \"fastshap\"){\n    shap_fs <- fastshap::explain(object, \n                                 X = df_shapbg_x, \n                                 newdata = as.data.frame(df_shap_x), \n                                 pred_wrapper = predfun, nsim = nsim)\n    sv <- shapviz(shap_fs, X = df_shap_x)\n    nsim_res <- nsim\n  }else if(method == \"treeshap\"){\n    obj_uni <- treeshap::unify(object, df_shap_x)\n    shap_ts <- treeshap::treeshap(obj_uni, x = df_shap_x)\n    sv <- shapviz(shap_ts)\n    nrow_shapbg_res <- 0\n  }else if(method == \"kernelshap\"){\n    shap_ks <- kernelshap(object, X = df_shap_x, bg_X = df_shapbg_x, pred_fun = predfun)\n    sv <- shapviz(shap_ks)\n  }\n  plot <- sv_importance(sv, kind = \"beeswarm\")\n  \n  t2 <- proc.time()\n  t0 <- (t2-t1)[3]\n  names(t0) <- NULL\n  return(list(method = method, nrow_shap = nrow_shap, nrow_shapbg = nrow_shapbg_res,\n              nsim = nsim_res, sv = sv, sv_importance = plot, time = t0))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#実際に計算時間の計測を行うループ\nresults <- tibble()\nresults_plots <- list()\nundebug(calc_shap)\nfor(r in 1:nrow(grid)){\n  model <- grid$model[[r]]\n  res <- calc_shap(object = modelsets[[model]]$object,\n            predfun = modelsets[[model]]$predfun,\n            method = grid$method[[r]],\n            nrow_shap = grid$nrow_shap[[r]],\n            nrow_shapbg = grid$nrow_shapbg[[r]],\n            nsim = grid$nsim[[r]])\n  rw <- list()\n  rw$model <- model\n  rw$method <- res$method\n  rw$nrow_shap <- res$nrow_shap\n  rw$nrow_shapbg <- res$nrow_shapbg\n  rw$nsim <- res$nsim\n  rw$time <- res$time\n  rw$id <- paste(rw$model, rw$method, rw$nrow_shap, rw$nrow_shapbg, rw$nsim, sep = \",\")\n  results <- bind_rows(results, as.tibble(rw))\n  \n  results_plots[[rw$id]] <- res\n  print(paste(rw$id, rw$time))\n}\n```\n:::\n\n\n\n\n\n\n\n## 参考文献\n\n::: {#refs}\n:::\n",
    "supporting": [
      "fastshap_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}